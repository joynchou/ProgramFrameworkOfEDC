C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE STC15_PWM
OBJECT MODULE PLACED IN .\stc15_pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\COMMON_HARDWARE\BSP\PWM\stc15_pwm.c LARGE WARNINGLEVEL(0) BR
                    -OWSE DEBUG OBJECTEXTEND PRINT(.\stc15_pwm.lst) TABS(2) OBJECT(.\stc15_pwm.obj)

line level    source

   1          /************************************************************
   2          * ×éÖ¯Ãû³Æ£º µç×Ó´óÈüÐ¡×é
   3          * ÎÄ¼þÃû³Æ: STC15_PWM.C
   4          * ×÷Õß:  ÖÜ³¿Ñô
   5          * °æ±¾:  1.3
   6          * ÈÕÆÚ:  2017/4/27
   7          * ÃèÊö:  Ó²¼þpwmµÄ¿âº¯Êý£¬io¿Ú²Î¼ûÏÂ·½½éÉÜ
   8          * ÀúÊ·ÐÞ¸Ä¼ÇÂ¼: // ÀúÊ·ÐÞ¸Ä¼ÇÂ¼
   9          * <×÷Õß> <Ê±¼ä> <°æ±¾ > <ÃèÊö>
  10          * ÖÜ³¿Ñô 2017/4/27 1.1 ÐÞ¸ÄÁËÒ»´¦´úÂë´íÎó£¬case²ÎÊý´íÎó
  11          * ÖÜ³¿Ñô 2017/5/6  1.2 Ôö¼ÓÁËÒ»Ð©³£ÓÃÉèÖÃº¯Êý
  12          * ÖÜ³¿Ñô 2017/7/9  1.3 ÐÞ¸ÄÁËpwmÐÅÏ¢µÄ¼ÇÂ¼ºÍ·µ»Ø·½Ê½£¬Ê¹ÓÃ½á¹¹ÌåÊý×éÀ´´æ·ÅÐÅÏ¢
  13          * ÖÜ³¿Ñô 2017/7/28 1.4 ÔÚÉèÖÃÆµÂÊµÄº¯ÊýÖÐÔö¼ÓÁË·ÀÖ¹³¬³öÉÏÏÞµÄÅÐ¶Ï£¬Èç¹û³¬³öÔòÊ¹ÓÃ×î´óÆµÂÊ
  14          ***********************************************************/
  15          
  16          #include "stc15_pwm.h"
  17          //PWMÐÅÏ¢´æ´¢
  18          /************************************
  19          Ó²¼þPWM ioÒý½Å
  20          PWM_N| µÚÒ»×é| µÚ¶þ×é
  21          PWM2 :P3.7 -> P2.7
  22          PWM3 :P2.1 -> P4.5
  23          PWM4 :P2.2 -> P4.4
  24          PWM5 :P2.3 -> P4.2
  25          PWM6 :P1.6 -> P0.7
  26          PWM7 :P1.7 -> P0.6
  27          ************************************/
  28          
  29          static struct PWM_N_INFO
  30          {
  31            u32 period;//pwmµÄÆµÂÊ
  32            u8 state;//pwm·¢ÉúÆ÷µÄ×´Ì¬
  33            float duty;//pwmµÄÕ¼¿Õ±È
  34            u8 DIV; //Ô¤·ÖÆµÖµ£¬ÓÃÀ´²úÉú½ÏµÍÆµÂÊµÄpwm
  35          };
  36          #define PWM_NUM 6
  37          static  struct PWM_N_INFO PWM_N_INFO[PWM_NUM]; //6×épwmÊý¾Ý´æ´¢
  38          
  39          /*************************************************
  40          * º¯ÊýÃû³Æ:void PWM_period(u16 Hz)
  41          * ÃèÊö: ÉèÖÃÓ²¼þpwmµÄÍ¬Ò»ÆµÂÊ £¬²¢±£´æÆµÂÊÊý¾Ý
  42          * ±»±¾º¯Êýµ÷ÓÃµÄº¯Êý:
  43          * 1.PWM_SET_PERIOD
  44          * ÊäÈë:u16 Hz:ÒªÊä³öµÄpwmµÄÆµÂÊ,ÓÉÓÚÓ²¼þËùÏÞ£¬½«»áÍ¬Ê±¸Ä±ä6Â·pwmµÄÆµÂÊ
  45          * Êä³ö: ÎÞ
  46          * ·µ»ØÖµ: ÎÞ
  47          * ÆäËû: ´Ëº¯ÊýÖ»ÄÜÉèÖÃpwmµÄ¼ÆÊýÆ÷³õÊ¼Öµ£¬´Ó¶øÍê³Épwm²»Í¬ÆµÂÊµÄÊä³ö£¬
  48              µ«ÊÇÓÉÓÚµ¥Æ¬»úÓ²¼þËùÏÞ£¬²»¿ÉÒÔµ¥¶À¶ÔÃ¿Â·pwmµÄÆµÂÊ½øÐÐÐÞ¸Ä£¬
  49              Ö»ÄÜÒ»¸ÄÈ«¸Ä¡£
  50          *************************************************/
  51          void set_PWM_period(u8 PWM_N, u16 Hz)
  52          {
  53   1        PWM_N_INFO[PWM_N].period = Hz;
  54   1        PWM_UNLOCK;
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 2   

  55   1        PWM_ALL_NO;
  56   1        PWM_SET_PERIOD((u16)(MAIN_Fosc / (Hz*PWM_N_INFO[PWM_N].DIV)));
  57   1        PWM_LOCK;
  58   1      
  59   1      
  60   1      }
  61          
  62          /*************************************************
  63          * º¯ÊýÃû³Æ: u32 getPWM_period(void )
  64          * ÃèÊö: ·µ»ØËùÉèÖÃµÄpwmÆµÂÊÐÅÏ¢
  65          * ÊäÈë: u8 PWM_N, 2<=N<=7
  66          * Êä³ö: ÎÞ
  67          * ·µ»ØÖµ: pwmÆµÂÊ
  68          * ÆäËûËµÃ÷: ÈôÃ»ÓÐÉèÖÃpwmµÄÆµÂÊ¾Íµ÷ÓÃ´Ëº¯ÊýÔò»á·µ»Ø0£»
  69          *************************************************/
  70          u32 get_PWM_period(u8 PWM_N)
  71          {
  72   1        return PWM_N_INFO[PWM_N].period;
  73   1      }
  74          /*************************************************
  75          * º¯ÊýÃû³Æ: void PWM_duty(u8 PWM_N,float duty)
  76          * ÃèÊö: ÐÞ¸ÄÄ³Ò»Â·pwmµÄÕ¼¿Õ±È £¬²¢±£´æÕ¼¿Õ±ÈÊý¾Ý
  77          * ±»±¾º¯Êýµ÷ÓÃµÄº¯Êý:
  78          * µ÷ÓÃ±¾º¯ÊýµÄº¯Êý:
  79          * ÊäÈë:
  80          * 1.u8 PWM_N £º ÄÄÒ»Â·pwm
  81          * 2.float duty£ºÕ¼¿Õ±È£¬Ê¹ÓÃÐ¡Êý£¬Èç0.8´ú±í80%µÄÕ¼¿Õ±È
  82          * Êä³ö: ÎÞ
  83          * ·µ»ØÖµ: ÎÞ
  84          * ÆäËûËµÃ÷:Îª·ÀÖ¹µçÆ½·¢Éú·´×ª£¬ÏÞÖÆ×îÐ¡Õ¼¿Õ±ÈÎª0.05£¬×î´óÎª0.95
  85          *          ¸ü¸ÄÁË×îµÍÕ¼¿Õ±ÈµÄÏÞ¶¨£¬ÓÃÓÚ·ûºÏ¶æ»úµÄ×îµÍÕ¼¿Õ±È¡ª¡ª¡ª¡ª0.05f -> 0.025f
  86          *************************************************/
  87          void set_PWM_duty(u8 PWM_N, float duty)
  88          {
  89   1        if (duty > 0.95f)
  90   1        {
  91   2          duty = 0.95f;
  92   2        }
  93   1        if (duty < 0.025f)
  94   1        {
  95   2          duty = 0.025f;
  96   2        }
  97   1        PWM_N_INFO[PWM_N].duty = duty;//´æ´¢Õ¼¿Õ±ÈÖµ
  98   1        PWM_UNLOCK;
  99   1        PWM_SET_T12_PERIOD(PWM_N, 10, (u16)(duty *  (MAIN_Fosc / (PWM_N_INFO[PWM_N].period*PWM_N_INFO[PWM_N].DIV))
             -));
 100   1        PWM_LOCK;
 101   1      }
 102          /*************************************************
 103          * º¯ÊýÃû³Æ: float getPWM_n_duty(u8 PWM_N)
 104          * ÃèÊö: ·µ»ØPWM_NµÄÕ¼¿Õ±ÈÐÅÏ¢
 105          * ÊäÈë: u8 PWM_N, 2<=N<=7
 106          * Êä³ö: ÎÞ
 107          * ·µ»ØÖµ: PWM_NµÄÕ¼¿Õ±ÈÐÅÏ¢,floatÐÎÊ½
 108          * ÆäËûËµÃ÷: ÈôÃ»ÓÐÉèÖÃpwmµÄÕ¼¿Õ±È¾Íµ÷ÓÃ´Ëº¯ÊýÔò»á·µ»Ø0£»
 109          *************************************************/
 110          float get_PWM_N_duty(u8 PWM_N)
 111          {
 112   1        return  PWM_N_INFO[PWM_N].duty;
 113   1      }
 114          
 115          //************************************
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 3   

 116          // Method:    setPWM_DIV
 117          // FullName:  setPWM_DIV
 118          // Access:    public 
 119          // Returns:   void
 120          // Qualifier: ÉèÖÃÔ¤·ÖÆµ£¬·¶Î§Îª1~16
 121          // Parameter: u8 PWM_N
 122          // Parameter: u8 DIV
 123          //************************************
 124          void setPWM_DIV(u8 PWM_N, u8 DIV)
 125          {
 126   1        PWM_N_INFO[PWM_N].DIV = DIV;
 127   1      }
 128          //************************************
 129          // Method:    getPWM_DIV
 130          // FullName:  getPWM_DIV
 131          // Access:    public 
 132          // Returns:   u8
 133          // Qualifier:
 134          // Parameter: u8 PWM_N
 135          //************************************
 136          u8 getPWM_DIV(u8 PWM_N)
 137          {
 138   1        return PWM_N_INFO[PWM_N].DIV;
 139   1      }
 140          //************************************
 141          // Method:    open_PWM_ALL
 142          // FullName:  open_PWM_ALL
 143          // Access:    public 
 144          // Returns:   void
 145          // Qualifier: ´ò¿ªËùÓÐÍ¨µÀpwm
 146          // Parameter: void
 147          //************************************
 148          void open_PWM_ALL(void)
 149          {
 150   1        PWM_UNLOCK;
 151   1        PWM_ALL_EN;
 152   1        PWM_LOCK;
 153   1      }
 154          //************************************
 155          // Method:    close_PWM_ALL
 156          // FullName:  close_PWM_ALL
 157          // Access:    public 
 158          // Returns:   void
 159          // Qualifier: ¹Ø±ÕËùÓÐÍ¨µÀµÄPWM
 160          // Parameter: void
 161          //************************************
 162          void close_PWM_ALL(void)
 163          {
 164   1        PWM_UNLOCK;
 165   1        PWM_ALL_NO; //×Ü¿ª¹Ø
 166   1        PWM_LOCK;
 167   1      
 168   1      }
 169          //************************************
 170          // Method:    open_PWM_N
 171          // FullName:  open_PWM_N
 172          // Access:    public 
 173          // Returns:   void
 174          // Qualifier: ´ò¿ªpwm_n
 175          // Parameter: u8 PWM_N
 176          //************************************
 177          void open_PWM_N(u8 PWM_N)
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 4   

 178          {
 179   1        PWM_UNLOCK;
 180   1        PWM_N_EN(PWM_N);
 181   1        PWM_N_INFO[PWM_N].state = ON;
 182   1        PWM_ALL_EN; //×Ü¿ª¹Ø,¸ù¾ÝÊÖ²áÖÐµÄÒªÇó
 183   1        PWM_LOCK;
 184   1      
 185   1      
 186   1      }
 187          //************************************
 188          // Method:    close_PWM_N
 189          // FullName:  close_PWM_N
 190          // Access:    public 
 191          // Returns:   void
 192          // Qualifier: ¹Ø±Õpwm_n
 193          // Parameter: u8 PWM_N
 194          //************************************
 195          void close_PWM_N(u8 PWM_N)
 196          {
 197   1        PWM_UNLOCK;
 198   1        PWM_N_NO(PWM_N);
 199   1        PWM_N_INFO[PWM_N].state = OFF;
 200   1        PWM_LOCK;
 201   1      
 202   1      }
 203          //************************************
 204          // Method:    get_PWM_N_state
 205          // FullName:  get_PWM_N_state
 206          // Access:    public 
 207          // Returns:   bit
 208          // Qualifier: ¶ÁÈ¡PWM_nµÄ×´Ì¬
 209          // Parameter: u8 PWM_N
 210          //************************************
 211          bit get_PWM_N_state(u8 PWM_N)
 212          {
 213   1      
 214   1        return  PWM_N_INFO[PWM_N].state;
 215   1      }
 216          
 217          //========================================================================
 218          //u8    PWM_Inilize(PWM_InitTypeDef *PWM)
 219          // ÃèÊö:PWM³õÊ¼»¯³ÌÐò£¬¸øÆäËûÄ£¿éÐèÒªÊ¹ÓÃpwmµÄÄ£¿éÊ¹ÓÃ
 220          // ²ÎÊý:u8 PWM_N:PWMÂ·Êý±êºÅ(2~7) PWM: ½á¹¹²ÎÊý,Çë²Î¿¼pwm.hÀïµÄ¶¨Òå.
 221          // ·µ»Ø: ³É¹¦·µ»Ø0, ´íÎó·µ»Ø1
 222          //========================================================================
 223          void PWM_Inilize(u8 PWM_N, PWM_InitTypeDef *PWMx)
 224          {
 225   1        u8 i = 0;
 226   1        for (; i < 6; i++)
 227   1        {
 228   2          PWM_N_INFO[i].period = 0;
 229   2          PWM_N_INFO[i].state = 0;
 230   2          PWM_N_INFO[i].duty = 0;
 231   2          PWM_N_INFO[i].DIV = 1;
 232   2        }
 233   1      
 234   1        P_SW2 |= 0X80;
 235   1        if (ENABLE == PWMx->PWM_GOTO_ADC)            //ENABLE=¼ÆÊýÆ÷¹éÁãÊ± ´¥·¢ADC
 236   1        {
 237   2          PWMCFG |= (1 << 7); //²¢µÄÒâË¼¾ÍÊÇ²»»á¸Ä±äÆäËûÎ»µÄÖµ
 238   2        }
 239   1        else
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 5   

 240   1        {
 241   2          PWMCFG &= (~(1 << 7)); //ÆäÊµÒ²¿ÉÒÔÓÃÉÏ±ßµÄ°ì·¨£¬µ«ÊÇÕâÑùÐ´µÄÒâË¼¸üÖ±¹Û
 242   2        }
 243   1        if (PWM_HIGHT == PWMx->PWM_V_INIT)              //PWM_HIGHT=³õÊ¼¸ßµçÆ½     PWM_LOW=³õÊ¼µÍµçÆ½
 244   1        {
 245   2          PWMCFG |= (1 << PWM_N);
 246   2        }
 247   1        else
 248   1        {
 249   2          PWMCFG &= (~(1 << PWM_N));
 250   2        }
 251   1        if (ENABLE == PWMx->PWM_0ISR_EN)             //ENABLE=Ê¹ÄÜPWM¼ÆÊýÆ÷¹éÁãÖÐ¶Ï  DISABLE=¹Ø±ÕPWM¼ÆÊýÆ÷¹éÁãÖÐ¶
             -Ï µ« CBIFÈÔÈ»»á±»Ó²¼þÖÃÎ»
 252   1        {
 253   2          PWMCR |= (1 << 6);
 254   2        }
 255   1        else
 256   1        {
 257   2          PWMCR &= (~(1 << 6));
 258   2        }
 259   1        if (ENABLE == PWMx->PWM_OUT_EN)              //ENABLE=PWMÍ¨µÀxµÄ¶Ë¿ÚÎªPWM²¨ÐÎÊä³ö¿Ú ÊÜPWM²¨ÐÎ·¢ÉúÆ÷¿ØÖÆ
 260   1        {
 261   2          PWMCR |= (1 << PWM_N);
 262   2        }
 263   1        else
 264   1        {
 265   2          PWMCR &= (~(1 << PWM_N));
 266   2        }
 267   1        if (ENABLE == PWMx->PWM_UNUSUAL_EN)          //ENABLE=Ê¹ÄÜPWMµÄÍâ²¿Òì³£¼ì²â¹¦ÄÜ
 268   1        {
 269   2          PWMFDCR = (1 << 5);
 270   2        }
 271   1        else
 272   1        {
 273   2          PWMFDCR &= (~(1 << 5));
 274   2        }
 275   1        if (ENABLE == PWMx->PWM_UNUSUAL_OUT)         //ENABLE=·¢ÉúÒì³£Ê±£¬PWM¶ÔÓ¦µÄÊä³ö¿Ú»á±ä³É ¸ß×èÊäÈëÄ£Ê½
 276   1        {
 277   2          PWMFDCR = (1 << 4);
 278   2        }
 279   1        else
 280   1        {
 281   2          PWMFDCR &= (~(1 << 4));
 282   2        }
 283   1        if (ENABLE == PWMx->PWM_UNUSUAL_ISR_EN)      //ENABLE=Ê¹ÄÜÒì³£¼ì²âÖÐ¶Ï DISABLE=¹Ø±ÕÒì³£¼ì²âÖÐ¶Ï µ«FDIFÈÔÈ
             -»»á±»Ó²¼þÖÃÎ»
 284   1        {
 285   2          PWMFDCR = (1 << 3);
 286   2        }
 287   1        else
 288   1        {
 289   2          PWMFDCR &= (~(1 << 3));
 290   2        }
 291   1        if (ENABLE == PWMx->PWM_UNUSUAL_CMP0_EN)     //ENABLE=Òì³£¼ì²âÔ´Îª±È½ÏÆ÷µÄÊä³ö µ±±È½Ï½á¹ûÎª¸ßÊ± ´¥·¢PWMÒì
             -³£
 292   1        {
 293   2          PWMFDCR = (1 << 2);
 294   2        }
 295   1        else
 296   1        {
 297   2          PWMFDCR &= (~(1 << 2));
 298   2        }
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 6   

 299   1        if (ENABLE == PWMx->PWM_UNUSUAL_P24_EN)      //ENABLE=Òì³£¼ì²âÔ´ÎªP24/PWMFLT µ±P24=1 ´¥·¢PWMÒì³£
 300   1        {
 301   2          PWMFDCR = (1 << 1);
 302   2        }
 303   1        else
 304   1        {
 305   2          PWMFDCR &= (~(1 << 1));
 306   2        }
 307   1        //  PWMCKS=0;
 308   1        if (PWM_Clock_NT == PWMx->PWM_CLOCK)               //PWM_Clock_NT=PWMµÄÊ±ÖÓÔ´ÊÇÏµÍ³Ê±ÖÓ¾­·ÖÆµºóµÄÊ±ÖÓ  PW
             -M_Clock_Timer2_OF=PWMµÄÊ±ÖÓÔ´ÊÇTMER2µÄÒç³öÂö³å
 309   1        {
 310   2          PWMCKS &= (~(1 << 4));
 311   2        }
 312   1        else
 313   1        {
 314   2          PWMCKS |= (1 << 4);
 315   2        }
 316   1        // PWMCKS=0x00;
 317   1        PWMCKS |= PWMx->PWM_CLOCK_DIV;           //µ±PWM_CLOCK=PWM_Clock_NTÊ± PWMµÄÊ±ÖÓÔ´ÊÇÏµÍ³Ê±ÖÓ/(PS[3:0]+1)
 318   1        switch (PWM_N)
 319   1        {
 320   2        case PWM_2:
 321   2        {
 322   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 323   3          {
 324   4            PWM2CR &= (~(1 << 3));
 325   4          }
 326   3          else
 327   3          {
 328   4            PWM2CR |= (1 << 3);
 329   4          }
 330   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 331   3          {
 332   4            PWM2CR |= (1 << 2);
 333   4          }
 334   3          else
 335   3          {
 336   4            PWM2CR &= (~(1 << 2));
 337   4          }
 338   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 339   3          {
 340   4            PWM2CR |= (1 << 1);
 341   4          }
 342   3          else
 343   3          {
 344   4            PWM2CR &= (~(1 << 1));
 345   4          }
 346   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 347   3          {
 348   4            PWM2CR |= (1 << 0);
 349   4          }
 350   3          else
 351   3          {
 352   4            PWM2CR &= (~(1 << 0));
 353   4          }
 354   3        }
 355   2        break;
 356   2        case PWM_3:
 357   2        {
 358   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 7   

             -Ñ¡ÔñIO¿Ú
 359   3          {
 360   4            PWM3CR &= (~(1 << 3));
 361   4          }
 362   3          else
 363   3          {
 364   4            PWM3CR |= (1 << 3);
 365   4          }
 366   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 367   3          {
 368   4            PWM3CR |= (1 << 2);
 369   4          }
 370   3          else
 371   3          {
 372   4            PWM3CR &= (~(1 << 2));
 373   4          }
 374   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 375   3          {
 376   4            PWM3CR |= (1 << 1);
 377   4          }
 378   3          else
 379   3          {
 380   4            PWM3CR &= (~(1 << 1));
 381   4          }
 382   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 383   3          {
 384   4            PWM3CR |= (1 << 0);
 385   4          }
 386   3          else
 387   3          {
 388   4            PWM3CR &= (~(1 << 0));
 389   4          }
 390   3        }
 391   2        break;
 392   2        case PWM_4:
 393   2        {
 394   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 395   3          {
 396   4            PWM4CR &= (~(1 << 3));
 397   4          }
 398   3          else
 399   3          {
 400   4            PWM4CR |= (1 << 3);
 401   4          }
 402   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 403   3          {
 404   4            PWM4CR |= (1 << 2);
 405   4          }
 406   3          else
 407   3          {
 408   4            PWM4CR &= (~(1 << 2));
 409   4          }
 410   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 411   3          {
 412   4            PWM4CR |= (1 << 1);
 413   4          }
 414   3          else
 415   3          {
 416   4            PWM4CR &= (~(1 << 1));
 417   4          }
 418   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 8   

 419   3          {
 420   4            PWM4CR |= (1 << 0);
 421   4          }
 422   3          else
 423   3          {
 424   4            PWM4CR &= (~(1 << 0));
 425   4          }
 426   3        }
 427   2        break;
 428   2        case PWM_5:
 429   2        {
 430   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 431   3          {
 432   4            PWM5CR &= (~(1 << 3));
 433   4          }
 434   3          else
 435   3          {
 436   4            PWM5CR |= (1 << 3);
 437   4          }
 438   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 439   3          {
 440   4            PWM5CR |= (1 << 2);
 441   4          }
 442   3          else
 443   3          {
 444   4            PWM5CR &= (~(1 << 2));
 445   4          }
 446   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 447   3          {
 448   4            PWM5CR |= (1 << 1);
 449   4          }
 450   3          else
 451   3          {
 452   4            PWM5CR &= (~(1 << 1));
 453   4          }
 454   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 455   3          {
 456   4            PWM5CR |= (1 << 0);
 457   4          }
 458   3          else
 459   3          {
 460   4            PWM5CR &= (~(1 << 0));
 461   4          }
 462   3        }
 463   2        break;
 464   2        case PWM_6:
 465   2        {
 466   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 467   3          {
 468   4            PWM6CR &= (~(1 << 3));
 469   4          }
 470   3          else
 471   3          {
 472   4            PWM6CR |= (1 << 3);
 473   4          }
 474   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 475   3          {
 476   4            PWM6CR |= (1 << 2);
 477   4          }
 478   3          else
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 9   

 479   3          {
 480   4            PWM6CR &= (~(1 << 2));
 481   4          }
 482   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 483   3          {
 484   4            PWM6CR |= (1 << 1);
 485   4          }
 486   3          else
 487   3          {
 488   4            PWM6CR &= (~(1 << 1));
 489   4          }
 490   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 491   3          {
 492   4            PWM6CR |= (1 << 0);
 493   4          }
 494   3          else
 495   3          {
 496   4            PWM6CR &= (~(1 << 0));
 497   4          }
 498   3        }
 499   2        break;
 500   2        case PWM_7:
 501   2        {
 502   3          if (PWM_SELECT_N == PWMx->PWM_SELECTx_IO)          //PWM_SELECT_N=PWMµÚÒ»Ñ¡ÔñIO¿Ú PWM_SELECT_N_2=PWMµÚ¶þ
             -Ñ¡ÔñIO¿Ú
 503   3          {
 504   4            PWM7CR &= (~(1 << 3));
 505   4          }
 506   3          else
 507   3          {
 508   4            PWM7CR |= (1 << 3);
 509   4          }
 510   3          if (ENABLE == PWMx->PWM_ISRx_EN)             //ENABLE=Ê¹ÄÜPWMxÖÐ¶Ï Ê¹ÄÜµÚÒ»·­×ª»òµÚ¶þ·­×ªÖÐ¶Ï
 511   3          {
 512   4            PWM7CR |= (1 << 2);
 513   4          }
 514   3          else
 515   3          {
 516   4            PWM7CR &= (~(1 << 2));
 517   4          }
 518   3          if (ENABLE == PWMx->PWM_T1x_EN)              //ENABLE=Ê¹ÄÜµÚÒ»·­×ªÖÐ¶Ï
 519   3          {
 520   4            PWM7CR |= (1 << 1);
 521   4          }
 522   3          else
 523   3          {
 524   4            PWM7CR &= (~(1 << 1));
 525   4          }
 526   3          if (ENABLE == PWMx->PWM_T2x_EN)              //ENABLE=Ê¹ÄÜµÚ¶þ·­×ªÖÐ¶Ï
 527   3          {
 528   4            PWM7CR |= (1 << 0);
 529   4          }
 530   3          else
 531   3          {
 532   4            PWM7CR &= (~(1 << 0));
 533   4          }
 534   3        }
 535   2        break;
 536   2        default:
 537   2          //      return 1;
 538   2          break;
 539   2        }
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 10  

 540   1        if (ENABLE == PWMx->PWM_EN)                  //ENABLE=PWMÊ¹ÄÜ ÔÚÆäËûPWM²ÎÊýÉèÖÃºÃºó×îºóÉèÖÃ Èç¹û±»¹Ø±ÕºóÔ
             -Ú´ò¿ª£¬ÔòPWM¼ÆÊýÆ÷ÖØÐÂ´Ó0¼ÆÊý
 541   1        {
 542   2          PWMCR |= (1 << 7);
 543   2        }
 544   1        else
 545   1        {
 546   2          PWMCR &= (~(1 << 7));
 547   2        }
 548   1      }
 549          //////////////£¡ÒÔÏÂÎªË½ÓÐº¯Êý£¬½ûÖ¹¸Ä¶¯£¡//////////////////////
 550          //
 551          //************************************
 552          // Method:    PWM_SET_PERIOD
 553          // FullName:  PWM_SET_PERIOD
 554          // Access:    public static 
 555          // Returns:   u8
 556          // Qualifier: ÉèÖÃPWMÖÜÆÚ
 557          // Parameter: u16 period
 558          //************************************
 559          static u8 PWM_SET_PERIOD(u16 period)
 560          {
 561   1        if (0x8000 > period) //2µÄ15´Î·½Îª×î´óÖµ
 562   1        {
 563   2          PWMCL = (u8)(period);
 564   2          PWMCH = (u8)(period >> 8);
 565   2          return 0;
 566   2        }
 567   1        else //Èç¹û´óÓÚµÈÓÚ0x8000£¬ÔòÄ¬ÈÏÊ¹ÓÃ×î´óÖÜÆÚ£¬¼È×îÐ¡ÆµÂÊ
 568   1        {
 569   2          PWMCL = (u8)(32767);
 570   2          PWMCH = (u8)(32767 >> 8);
 571   2        }
 572   1      }
 573          
 574          
 575          //************************************
 576          // Method:    PWM_SET_T12_PERIOD
 577          // FullName:  PWM_SET_T12_PERIOD
 578          // Access:    public static 
 579          // Returns:   u8
 580          // Qualifier: ÉèÖÃPWMµÚÒ»´ÎºÍµÚ¶þ´Î·­×ªÖÜÆÚ
 581          // Parameter: u8 PWM_N
 582          // Parameter: u16 period1
 583          // Parameter: u16 period2
 584          //************************************
 585          static u8 PWM_SET_T12_PERIOD(u8 PWM_N, u16 period1, u16 period2)
 586          {
 587   1        switch (PWM_N)
 588   1        {
 589   2        case PWM_2:
 590   2          PWM2T1L = (u8)(period1);
 591   2          PWM2T1H = (u8)(period1 >> 8);
 592   2          PWM2T2L = (u8)(period2);
 593   2          PWM2T2H = (u8)(period2 >> 8);
 594   2          return 0;
 595   2          break;
 596   2        case PWM_3:
 597   2          PWM3T1L = (u8)(period1);
 598   2          PWM3T1H = (u8)(period1 >> 8);
 599   2          PWM3T2L = (u8)(period2);
 600   2          PWM3T2H = (u8)(period2 >> 8);
C51 COMPILER V8.05a   STC15_PWM                                                            08/05/2017 09:36:40 PAGE 11  

 601   2          return 0;
 602   2          break;
 603   2        case PWM_4:
 604   2          PWM4T1L = (u8)(period1);
 605   2          PWM4T1H = (u8)(period1 >> 8);
 606   2          PWM4T2L = (u8)(period2);
 607   2          PWM4T2H = (u8)(period2 >> 8);
 608   2          return 0;
 609   2          break;
 610   2        case PWM_5:
 611   2          PWM5T1L = (u8)(period1);
 612   2          PWM5T1H = (u8)(period1 >> 8);
 613   2          PWM5T2L = (u8)(period2);
 614   2          PWM5T2H = (u8)(period2 >> 8);
 615   2          return 0;
 616   2          break;
 617   2        case PWM_6:
 618   2          PWM6T1L = (u8)(period1);
 619   2          PWM6T1H = (u8)(period1 >> 8);
 620   2          PWM6T2L = (u8)(period2);
 621   2          PWM6T2H = (u8)(period2 >> 8);
 622   2          return 0;
 623   2          break;
 624   2        case PWM_7:
 625   2          PWM7T1L = (u8)(period1);
 626   2          PWM7T1H = (u8)(period1 >> 8);
 627   2          PWM7T2L = (u8)(period2);
 628   2          PWM7T2H = (u8)(period2 >> 8);
 629   2          return 0;
 630   2          break;
 631   2        default:
 632   2          return 1;
 633   2          break;
 634   2        }
 635   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1633    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     60       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
