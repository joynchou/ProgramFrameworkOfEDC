C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\BSP\timer.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\timer.ls
                    -t) TABS(2) OBJECT(.\timer.obj)

line level    source

   1          /************************************************************
   2          * ļ: timer.c
   3          * : ܳ
   4          * 汾: 1.0
   5          * : 2017/4/29
   6          * : 嵥ƬƬ϶ʱʹá
   7          * Ҫ书 :
   8          * ʷ޸ļ¼:
   9          * <> <ʱ> <汾 > <>
  10          * ܳ 2017/4/29 ˴ļ˵ע
  11          * ܳ 2017/7/27 1.2 ˶ʱʹãڵĶʱ£
  12          * Timer 0 OS
  13          * Timer 1 1
  14          * Timer 2 pulser1
  15          * Timer 3 pulser2
  16          * Timer 4 ûʱ //ʱ޷ʹ
  17          * osʹʱʹãʱ
  18          * ⣬Էֳtimer4 ĸ޷ʹĶʱ
  19          * Ҫעʹõʱtimer2ĸǴ1 rxţصʱ뾡ôŲҪ
  20          * ܻʧ
  21          ***********************************************************/
  22          //////////////////////ʱӦ/////////////////////////////////////// 
  23          /*
  24          
  25          
  26                  setTimeout(Timer1,5000); //öʱʱ ,5
  27                  while(1)
  28                  {
  29                    if(isExpiredTimer(Timer1))   //ﵽʱʱ
  30                    {
  31                       stopTimer(Timer1);//ﵽʱʱһҪرնʱ޷ظʹöʱ
  32                      //ʱʱ䵽Ĵд
  33                    }
  34                    else//δﵽʱʱʱδ
  35                    {
  36          
  37          
  38                        restartTimer(Timer1);
  39          
  40          
  41                    }
  42                  }
  43          */
  44          ///////////////////////////////////////////////////////////////    
  45          #include  "timer.h"
  46          #include "USART1.h"
  47          #include <limits.h>
  48          #include <assert.h>
  49          #include <stdlib.h>
  50          #include <stdio.h>
  51          enum
  52          {
  53            ACTIVE, EXPIRED, STOPPED
  54          }
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 2   

  55          Timer1_state = STOPPED,
  56          Timer2_state = STOPPED;
  57          
  58          static u16 Timer1_temp = 0;
  59          static u16 Timer2_temp = 0;
  60          static u16 micros = 0;//ʱȡ
  61          static u16 millis = 0;//ʱȡ
  62          static u8 seconds = 0;
  63          static u8 minutes = 0;
  64          static u8 hours = 0;
  65          static u8 days = 0;
  66          
  67          
  68          
  69          
  70          struct TimerInfo
  71          {
  72            u16 Timeout;
  73            u16 Hz;
  74          }
  75          timer1_struct = { 0,0 },
  76          timer2_struct = { 0,0 };
  77          //************************************
  78          // Method:    timerInit
  79          // FullName:  timerInit
  80          // Access:    public 
  81          // Returns:   void
  82          // Qualifier: ʱʼʹûʱ;ʱȡ֮ǰsetupеô˺ɳʼ
  83          //************************************
  84          void timerInit()
  85          {
  86   1        TIM_InitTypeDef   USER_Timer; //ûԶ嶨ʱʹ
  87   1        TIM_InitTypeDef   Pulser_1_Timer; //
  88   1        TIM_InitTypeDef   Pulser_2_Timer;
  89   1        u8 Error_Code = 0;
  90   1        //  
  91   1        //    //ûԶ嶨ʱ    
  92   1        USER_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ    TIM_16BitAutoReload,TIM_16B
             -it,TIM_8BitAutoReload,\\                                                                                                                TIM_16BitAutoReloadNoMask
  93   1        USER_Timer.TIM_Polity = PolityLow;      //ָжȼ, PolityHigh,PolityLow
  94   1        USER_Timer.TIM_Interrupt = DISABLE;       //жǷ,   ENABLEDISABLE
  95   1        USER_Timer.TIM_ClkSource = TIM_CLOCK_1T;  //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
  96   1        USER_Timer.TIM_ClkOut = DISABLE;        //Ƿ, ENABLEDISABLE
  97   1        USER_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
  98   1        USER_Timer.TIM_Value = 65536UL - (MAIN_Fosc / 1000);    //ֵ,1000us
  99   1        //巢1Ķʱ
 100   1        Pulser_1_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload,\\                                                                                                                   TIM_16BitAutoReloadNoMask
 101   1        Pulser_1_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 102   1        Pulser_1_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 103   1        Pulser_1_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 104   1        //Pulser_1_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 105   1        Pulser_1_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 106   1      
 107   1        //巢2Ķʱ
 108   1        Pulser_2_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload                                                                                                                                            //TIM_16BitAutoReloadNoMa
             -sk
 109   1        Pulser_2_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 110   1        Pulser_2_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 111   1        Pulser_2_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 112   1        //Pulser_2_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 3   

 113   1        Pulser_2_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 114   1      
 115   1        Timer_Inilize(Timer2, &Pulser_1_Timer);
 116   1        Timer_Inilize(Timer3, &Pulser_2_Timer);
 117   1      
 118   1        //    //ûԶ嶨ʱ    
 119   1        //      if (!(Error_Code = Timer_Inilize(Timer4, &USER_Timer)))//==0
 120   1        //      {
 121   1        //        //PrintString1("USER_Timer initializing succeed \r\n");
 122   1        //      }
 123   1        //      else if (Error_Code) //==1
 124   1        //      {
 125   1        //        //PrintString1("USER_Timer initializing failed \r\n");
 126   1        //      }
 127   1        //      else
 128   1        //      {
 129   1        //        //PrintString1("USER_Timer initializing failed \r\n");
 130   1        //      }
 131   1      
 132   1        //  //巢1Ķʱ
 133   1        //  if (!(Error_Code = Timer_Inilize(Timer1, &TIM_InitStructure)))//==0
 134   1        //  {
 135   1        //    //PrintString1("Pulser_1_Timer initializing succeed \r\n" );
 136   1        //  }
 137   1        //  else if (Error_Code) //==1
 138   1        //  {
 139   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 140   1        //  }
 141   1        //  else
 142   1        //  {
 143   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 144   1        //  }
 145   1        //  //巢2Ķʱ
 146   1        //  if (!(Error_Code = Timer_Inilize(Timer3, &Pulser_2_Timer)))//==0
 147   1        //  {
 148   1        //    //PrintString1("Pulser_2_Timer initializing succeed \r\n");
 149   1        //  }
 150   1        //  else if (Error_Code) //==1
 151   1        //  {
 152   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 153   1        //  }
 154   1        //  else
 155   1        //  {
 156   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 157   1        //  }
 158   1      
 159   1      
 160   1      
 161   1      }
 162          
 163          //
 164          //************************************
 165          // Method:    setTimeout
 166          // FullName:  setTimeout
 167          // Access:    public 
 168          // Returns:   void
 169          // Qualifier: öʱĶʱʱ
 170          // Parameter: u8 whichTimerһʱ
 171          // Parameter: u16 timeҪʱʱ䣬λms
 172          //************************************
 173          void setTimeout(u8 whichTimer, u16 time)
 174          {
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 4   

 175   1        if (!(Timer1_state == ACTIVE || Timer2_state == ACTIVE))
 176   1        {
 177   2          switch (whichTimer)
 178   2          {
 179   3      
 180   3          case Timer1:
 181   3          {
 182   4            timer1_struct.Timeout = time;
 183   4          };
 184   3          case Timer2:
 185   3          {
 186   4            timer2_struct.Timeout = time;
 187   4          };
 188   3          default:
 189   3            break;
 190   3          }
 191   2        }
 192   1      }
 193          //************************************
 194          // Method:    getTimerout
 195          // FullName:  getTimerout
 196          // Access:    public 
 197          // Returns:   u16
 198          // Qualifier:
 199          // Parameter: u8 whichTimer
 200          //************************************
 201          u16 getTimerout(u8 whichTimer)
 202          {
 203   1        switch (whichTimer)
 204   1        {
 205   2      
 206   2        case Timer1:
 207   2        {
 208   3          return timer1_struct.Timeout;
 209   3        };
 210   2        break;
 211   2        case Timer2:
 212   2        {
 213   3          return timer2_struct.Timeout;
 214   3        };
 215   2        break;
 216   2      
 217   2        default: return 0;
 218   2        }
 219   1      
 220   1      }
 221          //
 222          //************************************
 223          // Method:    setTimerHertz
 224          // FullName:  setTimerHertz
 225          // Access:    public 
 226          // Returns:   void
 227          // Qualifier: öʱķƵ
 228          // Parameter: u8 whichTimerһʱ
 229          // Parameter: u16 HzƵ
 230          //************************************
 231          void setTimerHertz(u8 whichTimer, u16 Hz)
 232          {
 233   1        switch (whichTimer)
 234   1        {
 235   2      
 236   2        case Timer1:
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 5   

 237   2        {
 238   3          timer1_struct.Hz = Hz;
 239   3        };
 240   2        break;
 241   2        case Timer2:
 242   2        {
 243   3          timer2_struct.Hz = Hz;
 244   3        };
 245   2        break;
 246   2      
 247   2        }
 248   1      
 249   1      
 250   1      }
 251          u16 getTimerHertz(u8 whichTimer)
 252          {
 253   1        switch (whichTimer)
 254   1        {
 255   2      
 256   2          break;
 257   2        case Timer1:
 258   2        {
 259   3          return timer1_struct.Hz;
 260   3        };
 261   2        break;
 262   2        case Timer2:
 263   2        {
 264   3          return timer2_struct.Hz;
 265   3        };
 266   2        break;
 267   2        default: return 0;
 268   2        }
 269   1      }
 270          //ͣöʱ
 271          //************************************
 272          // Method:    stopTimer
 273          // FullName:  stopTimer
 274          // Access:    public 
 275          // Returns:   void
 276          // Qualifier: ֹͣӦĶʱ
 277          // Parameter: u8 whichTimer
 278          //************************************
 279          void stopTimer(u8 whichTimer)
 280          {
 281   1        switch (whichTimer)
 282   1        {
 283   2        case Timer1:
 284   2        {
 285   3          Timer4_Stop();
 286   3          Timer1_state = STOPPED;
 287   3      
 288   3        };
 289   2        break;
 290   2        case Timer2:
 291   2        {
 292   3          //    Timer3_Stop();//˴timer3timer2timer2ˣΪʹ    
 293   3          //    Timer2_state = STOPPED;
 294   3      
 295   3        };
 296   2        break;
 297   2        }
 298   1      
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 6   

 299   1      }
 300          //ʱδﵽʱʱ䷵1
 301          //************************************
 302          // Method:    isActiveTimer
 303          // FullName:  isActiveTimer
 304          // Access:    public 
 305          // Returns:   bit
 306          // Qualifier: ǰʱڶʱŷ1Ϊ0
 307          // Parameter: u8 whichTimer
 308          //************************************
 309          bit isActiveTimer(u8 whichTimer)
 310          {
 311   1        switch (whichTimer)
 312   1        {
 313   2        case Timer1:
 314   2        {
 315   3          return  Timer1_state == ACTIVE;
 316   3      
 317   3        };
 318   2        case Timer2:
 319   2        {
 320   3          return  Timer2_state == ACTIVE;
 321   3      
 322   3        };
 323   2        break;
 324   2        }
 325   1      }
 326          //ʱﵽ趨ʱʱ1
 327          //************************************
 328          // Method:    isExpiredTimer
 329          // FullName:  isExpiredTimer
 330          // Access:    public 
 331          // Returns:   bit
 332          // Qualifier: ʱĶʱʱѵ򷵻1
 333          // Parameter: u8 whichTimer
 334          //************************************
 335          bit isExpiredTimer(u8 whichTimer)
 336          {
 337   1        switch (whichTimer)
 338   1        {
 339   2        case Timer1:
 340   2        {
 341   3          return  Timer1_state == EXPIRED;
 342   3        };
 343   2        case Timer2:
 344   2        {
 345   3          return  Timer2_state == EXPIRED;
 346   3        };
 347   2        break;
 348   2        }
 349   1      
 350   1      
 351   1      }
 352          //ʱֹͣʱ1
 353          //************************************
 354          // Method:    isStopped
 355          // FullName:  isStopped
 356          // Access:    public 
 357          // Returns:   bit
 358          // Qualifier: ʱѾֹͣ򷵻1
 359          // Parameter: u8 whichtimer
 360          //************************************
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 7   

 361          bit isStopped(u8 whichtimer)
 362          {
 363   1        switch (whichtimer)
 364   1        {
 365   2        case Timer1:
 366   2        {
 367   3          return  Timer1_state == STOPPED;
 368   3        };
 369   2        case Timer2:
 370   2        {
 371   3          return  Timer2_state == STOPPED;
 372   3        };
 373   2        break;
 374   2        }
 375   1      }
 376          
 377          //
 378          //************************************
 379          // Method:    restartTimer
 380          // FullName:  restartTimer
 381          // Access:    public 
 382          // Returns:   void
 383          // Qualifier: ʼ򿪶ʱҪúöʱʱƵ
 384          // Parameter: u8 whichTimer
 385          //************************************
 386          void restartTimer(u8 whichTimer)
 387          {
 388   1        if (!isActiveTimer(whichTimer))
 389   1        {
 390   2          switch (whichTimer)
 391   2          {
 392   3          case Timer1:
 393   3          {
 394   4            Timer4_Run();
 395   4            Timer1_state = ACTIVE;
 396   4          };
 397   3          break;
 398   3          case Timer2:
 399   3          {
 400   4            //      Timer3_Run();
 401   4            //      Timer2_state = ACTIVE;
 402   4          };
 403   3          break;
 404   3          default:
 405   3            break;
 406   3          }
 407   2      
 408   2      
 409   2      
 410   2        }
 411   1      }
 412          //
 413          //************************************
 414          // Method:    onRestartTimer
 415          // FullName:  onRestartTimer
 416          // Access:    public 
 417          // Returns:   bit
 418          // Qualifier: ʱʱ󷵻1Զrestart¶ʱԴѭ
 419          // Parameter: u8 whichTimer
 420          //************************************
 421          bit onRestartTimer(u8 whichTimer)
 422          {
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 8   

 423   1        if (isExpiredTimer(whichTimer))
 424   1        {
 425   2          restartTimer(whichTimer);
 426   2          return TRUE;
 427   2        }
 428   1        else
 429   1        {
 430   2          return FALSE;
 431   2        }
 432   1      
 433   1      }
 434          
 435          
 436          //ȡӿ΢
 437          u16 getMicros(void)
 438          {
 439   1      
 440   1        return  micros;
 441   1      }
 442          //ȡӿĺ
 443          u16 getMillis(void)
 444          {
 445   1        return millis;
 446   1      }
 447          u8 getSeconds(void)
 448          {
 449   1        return seconds;
 450   1      }
 451          u8 getMinutes(void)
 452          {
 453   1        return minutes;
 454   1      }
 455          u8 getHours(void)
 456          {
 457   1        return hours;
 458   1      }
 459          u8 getDays(void)
 460          {
 461   1        return days;
 462   1      }
 463          
 464          //========================˽кҪ˽ҲҪĶκγ򣡣=================//
 465          /********************* Timer1жϺ************************/
 466          //static void Timer1_ISR(void) interrupt TIMER1_VECTOR
 467          //{
 468          
 469          //  if ((++Timer1_temp) >= timer1_struct.Timeout)
 470          //  {
 471          //    Timer1_Stop();
 472          //    Timer1_temp = 0;
 473          //    Timer1_state = EXPIRED;
 474          //  }
 475          
 476          
 477          
 478          //}
 479          
 480          // static void timer3_int(void) interrupt TIMER2_VECTOR
 481          //{
 482          //  if ((++Timer2_temp) >= 30)
 483          //  {
 484          //    Timer2_Stop();
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 9   

 485          //    Timer2_temp = 0;
 486          //    Timer2_state = EXPIRED;
 487          //  }
 488          
 489          //}
 490          
 491          /********************* Timer3жϺ************************/
 492          //static void timer3_int(void) interrupt TIMER3_VECTOR
 493          //{
 494          //  if ((++Timer2_temp) >= timer2_struct.Timeout)
 495          //  {
 496          //    Timer3_Stop();
 497          //    Timer2_temp = 0;
 498          //    Timer2_state = EXPIRED;
 499          //  }
 500          
 501          //}
 502          /********************* Timer4жϺ************************/
 503          //
 504          //sprintfʹòµʵֵûд
 505          //static void timer4_int(void) interrupt TIMER4_VECTOR
 506          //{
 507          
 508          
 509          //  EA = 0;
 510          //  if ((micros += 10) >= 1000)
 511          //  {
 512          //    micros = 0;
 513          //    if ((++millis) >= 1000)
 514          //    {
 515          //      millis = 0;
 516          //      if ((++seconds) >= 60)
 517          //      {
 518          //        seconds = 0;
 519          //        if ((++minutes) >= 60)
 520          //        {
 521          //          minutes = 0;
 522          //          if ((++hours) >= 24)
 523          //          {
 524          //            hours = 0;
 525          //            if ((++days) == UCHAR_MAX)
 526          //            {
 527          //              days = 0;
 528          //            }
 529          
 530          //          }
 531          //        }
 532          
 533          //      }
 534          //    }
 535          //  }
 536          
 537          //  EA = 1;
 538          //}
 539          /********************* Timer2жϺ************************/
 540          //˶ʱڵĶʱ
 541          //void Timer2_ISR (void) interrupt TIMER2_VECTOR
 542          //{
 543          //  
 544          //}
 545          
 546          
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 10  

 547          // : u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 548          // : ʱʼ.
 549          // : TIMx: ṹ,οtimer.hĶ.
 550          // : ɹ0, ղ1,󷵻2.
 551          // 汾: V1.0, 2012-10-22
 552          //========================================================================
 553          static u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 554          {
 555   1        if (TIM > Timer4) return 1; //ղ
 556   1      
 557   1        if (TIM == Timer0)
 558   1        {
 559   2          if (TIMx->TIM_Mode > TIM_16BitAutoReloadNoMask) return 2; //
 560   2          TR0 = 0;    //ֹͣ
 561   2          ET0 = 0;  //ֹж
 562   2          PT0 = 0;  //ȼж
 563   2          TMOD &= 0xf0; //ʱģʽ, 16λԶװ
 564   2          AUXR &= ~0x80;  //12Tģʽ, 
 565   2          INT_CLKO &= ~0x01;  //ʱ
 566   2          if (TIMx->TIM_Interrupt == ENABLE)    ET0 = 1;  //ж
 567   2          if (TIMx->TIM_Polity == PolityHigh)   PT0 = 1;  //ȼж
 568   2          TMOD |= TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ, 3: 16λԶװ, 
             -ж
 569   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x80; //1T
 570   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x04; //Ƶ
 571   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x01; //ʱ
 572   2      
 573   2          TH0 = (u8)(TIMx->TIM_Value >> 8);
 574   2          TL0 = (u8)TIMx->TIM_Value;
 575   2          if (TIMx->TIM_Run == ENABLE)  TR0 = 1;  //ʼ
 576   2          return  0;    //ɹ
 577   2        }
 578   1      
 579   1        if (TIM == Timer1)
 580   1        {
 581   2          TR1 = 0;    //ֹͣ
 582   2          if (TIMx->TIM_Interrupt == ENABLE)    ET1 = 1;  //ж
 583   2          else                  ET1 = 0;  //ֹж
 584   2          if (TIMx->TIM_Polity == PolityHigh)   PT1 = 1;  //ȼж
 585   2          else                  PT1 = 0;  //ȼж
 586   2          if (TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask)  return 2; //
 587   2          TMOD = (TMOD & ~0x30) | TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ
 588   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~0x40;  //12T
 589   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x40; //1T
 590   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x40; //Ƶ
 591   2          else                    TMOD &= ~0x40;  //ʱ
 592   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x02; //ʱ
 593   2          else              INT_CLKO &= ~0x02;  //ʱ
 594   2      
 595   2          TH1 = (u8)(TIMx->TIM_Value >> 8);
 596   2          TL1 = (u8)TIMx->TIM_Value;
 597   2          if (TIMx->TIM_Run == ENABLE)  TR1 = 1;  //ʼ
 598   2          return  0;    //ɹ
 599   2        }
 600   1      
 601   1        if (TIM == Timer2)    //Timer2,̶Ϊ16λԶװ, жȼ
 602   1        {
 603   2          AUXR &= ~(1 << 4);  //ֹͣ
 604   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 2);  //ж
 605   2          else                    IE2 &= ~(1 << 2); //ֹж
 606   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 607   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~(1 << 2);  //12T
C51 COMPILER V8.05a   TIMER                                                                07/28/2017 09:53:38 PAGE 11  

 608   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= (1 << 2); //1T
 609   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) AUXR |= (1 << 3); //Ƶ
 610   2          else                    AUXR &= ~(1 << 3);  //ʱ
 611   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x04; //ʱ
 612   2          else              INT_CLKO &= ~0x04;  //ʱ
 613   2      
 614   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 615   2          TL2 = (u8)TIMx->TIM_Value;
 616   2          if (TIMx->TIM_Run == ENABLE)  AUXR |= (1 << 4); //ʼ
 617   2          return  0;    //ɹ
 618   2        }
 619   1      
 620   1        if (TIM == Timer3)    //Timer3,̶Ϊ16λԶװ, жȼ
 621   1        {
 622   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 623   2          T4T3M &= 0xf0;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 624   2          IE2 &= ~(1 << 5); //ֹж
 625   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 5);  //ж
 626   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 1);  //1T
 627   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 1);  //Ƶ
 628   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= 1; //ʱ
 629   2      
 630   2          TH3 = (u8)(TIMx->TIM_Value >> 8);
 631   2          TL3 = (u8)TIMx->TIM_Value;
 632   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 3);  //ʼ
 633   2          return  0;    //ɹ
 634   2        }
 635   1      
 636   1        if (TIM == Timer4)    //Timer4,̶Ϊ16λԶװ, жȼ
 637   1        {
 638   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 639   2          T4T3M &= 0x0f;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 640   2          IE2 &= ~(1 << 6); //ֹж
 641   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 6);  //ж
 642   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 5);  //1T
 643   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 5);  //Ƶ
 644   2      
 645   2          TH4 = (u8)(TIMx->TIM_Value >> 8);
 646   2          TL4 = (u8)TIMx->TIM_Value;
 647   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 7);  //ʼ
 648   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= (1 << 4);  //ʱ
 649   2      
 650   2          return  0;    //ɹ
 651   2        }
 652   1      
 653   1        return 2; //
 654   1      }
 655          
 656          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    976    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
