C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\COMMON_HARDWARE\BSP\timer\timer.c LARGE WARNINGLEVEL(0) BROW
                    -SE DEBUG OBJECTEXTEND PRINT(.\timer.lst) TABS(2) OBJECT(.\timer.obj)

line level    source

   1          /************************************************************
   2          * ļ: timer.c
   3          * : ܳ
   4          * 汾: 1.0
   5          * : 2017/4/29
   6          * : 嵥ƬƬ϶ʱʹá
   7          * Ҫ书 :
   8          * ʷ޸ļ¼:
   9          * <> <ʱ> <汾 > <>
  10          * ܳ 2017/4/29 ˴ļ˵ע
  11          * ܳ 2017/7/27 1.2 ˶ʱʹãڵĶʱ£
  12          * Timer 0 OS
  13          * Timer 1 1
  14          * Timer 2 pulser1
  15          * Timer 3 pulser2
  16          * Timer 4 ûʱ //ʱ޷ʹ
  17          * osʹʱʹãʱ
  18          * ⣬Էֳtimer4 ĸ޷ʹĶʱ
  19          * Ҫעʹõʱtimer2ĸǴ1 rxţصʱ뾡ôŲҪ
  20          * ܻʧ
  21          ***********************************************************/
  22          //////////////////////ʱӦ/////////////////////////////////////// 
  23          /*
  24          
  25          
  26                  setTimeout(Timer1,5000); //öʱʱ ,5
  27                  while(1)
  28                  {
  29                    if(isExpiredTimer(Timer1))   //ﵽʱʱ
  30                    {
  31                       stopTimer(Timer1);//ﵽʱʱһҪرնʱ޷ظʹöʱ
  32                      //ʱʱ䵽Ĵд
  33                    }
  34                    else//δﵽʱʱʱδ
  35                    {
  36          
  37          
  38                        restartTimer(Timer1);
  39          
  40          
  41                    }
  42                  }
  43          */
  44          ///////////////////////////////////////////////////////////////
  45          #include <limits.h>
  46          #include <assert.h>
  47          #include <stdlib.h>
  48          #include <stdio.h>
  49          
  50          
  51          #include  "timer.h"
  52          enum
  53          {
  54            ACTIVE, EXPIRED, STOPPED
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 2   

  55          }
  56          Timer1_state = STOPPED,
  57          Timer2_state = STOPPED;
  58          
  59          static u16 Timer1_temp = 0;
  60          static u16 Timer2_temp = 0;
  61          static u16 micros = 0;//ʱȡ
  62          static u16 millis = 0;//ʱȡ
  63          static u8 seconds = 0;
  64          static u8 minutes = 0;
  65          static u8 hours = 0;
  66          static u8 days = 0;
  67          
  68          
  69          
  70          
  71          struct TimerInfo
  72          {
  73            u16 Timeout;
  74            u16 Hz;
  75          }
  76          timer1_struct = { 0,0 },
  77          timer2_struct = { 0,0 };
  78          //************************************
  79          // Method:    timerInit
  80          // FullName:  timerInit
  81          // Access:    public 
  82          // Returns:   void
  83          // Qualifier: ʱʼʹûʱ;ʱȡ֮ǰsetupеô˺ɳʼ
  84          //************************************
  85          void timerInit()
  86          {
  87   1        TIM_InitTypeDef   USER_Timer; //ûԶ嶨ʱʹ
  88   1        TIM_InitTypeDef   Pulser_1_Timer; //
  89   1        TIM_InitTypeDef   Pulser_2_Timer;
  90   1        u8 Error_Code = 0;
  91   1        //  
  92   1        //    //ûԶ嶨ʱ    
  93   1        USER_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ    TIM_16BitAutoReload,TIM_16B
             -it,TIM_8BitAutoReload,\\                                                                                                                TIM_16BitAutoReloadNoMask
  94   1        USER_Timer.TIM_Polity = PolityLow;      //ָжȼ, PolityHigh,PolityLow
  95   1        USER_Timer.TIM_Interrupt = DISABLE;       //жǷ,   ENABLEDISABLE
  96   1        USER_Timer.TIM_ClkSource = TIM_CLOCK_1T;  //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
  97   1        USER_Timer.TIM_ClkOut = DISABLE;        //Ƿ, ENABLEDISABLE
  98   1        USER_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
  99   1        USER_Timer.TIM_Value = 65536UL - (MAIN_Fosc / 1000);    //ֵ,1000us
 100   1        //巢1Ķʱ
 101   1        Pulser_1_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload,\\                                                                                                                   TIM_16BitAutoReloadNoMask
 102   1        Pulser_1_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 103   1        Pulser_1_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 104   1        Pulser_1_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 105   1        //Pulser_1_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 106   1        Pulser_1_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 107   1      
 108   1        //巢2Ķʱ
 109   1        Pulser_2_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload                                                                                                                                            //TIM_16BitAutoReloadNoMa
             -sk
 110   1        Pulser_2_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 111   1        Pulser_2_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 112   1        Pulser_2_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 3   

 113   1        //Pulser_2_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 114   1        Pulser_2_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 115   1      
 116   1        Timer_Inilize(Timer2, &Pulser_1_Timer);
 117   1        Timer_Inilize(Timer3, &Pulser_2_Timer);
 118   1      
 119   1        //    //ûԶ嶨ʱ    
 120   1        //      if (!(Error_Code = Timer_Inilize(Timer4, &USER_Timer)))//==0
 121   1        //      {
 122   1        //        //PrintString1("USER_Timer initializing succeed \r\n");
 123   1        //      }
 124   1        //      else if (Error_Code) //==1
 125   1        //      {
 126   1        //        //PrintString1("USER_Timer initializing failed \r\n");
 127   1        //      }
 128   1        //      else
 129   1        //      {
 130   1        //        //PrintString1("USER_Timer initializing failed \r\n");
 131   1        //      }
 132   1      
 133   1        //  //巢1Ķʱ
 134   1        //  if (!(Error_Code = Timer_Inilize(Timer1, &TIM_InitStructure)))//==0
 135   1        //  {
 136   1        //    //PrintString1("Pulser_1_Timer initializing succeed \r\n" );
 137   1        //  }
 138   1        //  else if (Error_Code) //==1
 139   1        //  {
 140   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 141   1        //  }
 142   1        //  else
 143   1        //  {
 144   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 145   1        //  }
 146   1        //  //巢2Ķʱ
 147   1        //  if (!(Error_Code = Timer_Inilize(Timer3, &Pulser_2_Timer)))//==0
 148   1        //  {
 149   1        //    //PrintString1("Pulser_2_Timer initializing succeed \r\n");
 150   1        //  }
 151   1        //  else if (Error_Code) //==1
 152   1        //  {
 153   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 154   1        //  }
 155   1        //  else
 156   1        //  {
 157   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 158   1        //  }
 159   1      
 160   1      
 161   1      
 162   1      }
 163          
 164          //
 165          //************************************
 166          // Method:    setTimeout
 167          // FullName:  setTimeout
 168          // Access:    public 
 169          // Returns:   void
 170          // Qualifier: öʱĶʱʱ
 171          // Parameter: u8 whichTimerһʱ
 172          // Parameter: u16 timeҪʱʱ䣬λms
 173          //************************************
 174          void setTimeout(u8 whichTimer, u16 time)
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 4   

 175          {
 176   1        if (!(Timer1_state == ACTIVE || Timer2_state == ACTIVE))
 177   1        {
 178   2          switch (whichTimer)
 179   2          {
 180   3      
 181   3          case Timer1:
 182   3          {
 183   4            timer1_struct.Timeout = time;
 184   4          };
 185   3          case Timer2:
 186   3          {
 187   4            timer2_struct.Timeout = time;
 188   4          };
 189   3          default:
 190   3            break;
 191   3          }
 192   2        }
 193   1      }
 194          //************************************
 195          // Method:    getTimerout
 196          // FullName:  getTimerout
 197          // Access:    public 
 198          // Returns:   u16
 199          // Qualifier:
 200          // Parameter: u8 whichTimer
 201          //************************************
 202          u16 getTimerout(u8 whichTimer)
 203          {
 204   1        switch (whichTimer)
 205   1        {
 206   2      
 207   2        case Timer1:
 208   2        {
 209   3          return timer1_struct.Timeout;
 210   3        };
 211   2        break;
 212   2        case Timer2:
 213   2        {
 214   3          return timer2_struct.Timeout;
 215   3        };
 216   2        break;
 217   2      
 218   2        default: return 0;
 219   2        }
 220   1      
 221   1      }
 222          //
 223          //************************************
 224          // Method:    setTimerHertz
 225          // FullName:  setTimerHertz
 226          // Access:    public 
 227          // Returns:   void
 228          // Qualifier: öʱķƵ
 229          // Parameter: u8 whichTimerһʱ
 230          // Parameter: u16 HzƵ
 231          //************************************
 232          void setTimerHertz(u8 whichTimer, u16 Hz)
 233          {
 234   1        switch (whichTimer)
 235   1        {
 236   2      
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 5   

 237   2        case Timer1:
 238   2        {
 239   3          timer1_struct.Hz = Hz;
 240   3        };
 241   2        break;
 242   2        case Timer2:
 243   2        {
 244   3          timer2_struct.Hz = Hz;
 245   3        };
 246   2        break;
 247   2      
 248   2        }
 249   1      
 250   1      
 251   1      }
 252          u16 getTimerHertz(u8 whichTimer)
 253          {
 254   1        switch (whichTimer)
 255   1        {
 256   2      
 257   2          break;
 258   2        case Timer1:
 259   2        {
 260   3          return timer1_struct.Hz;
 261   3        };
 262   2        break;
 263   2        case Timer2:
 264   2        {
 265   3          return timer2_struct.Hz;
 266   3        };
 267   2        break;
 268   2        default: return 0;
 269   2        }
 270   1      }
 271          //ͣöʱ
 272          //************************************
 273          // Method:    stopTimer
 274          // FullName:  stopTimer
 275          // Access:    public 
 276          // Returns:   void
 277          // Qualifier: ֹͣӦĶʱ
 278          // Parameter: u8 whichTimer
 279          //************************************
 280          void stopTimer(u8 whichTimer)
 281          {
 282   1        switch (whichTimer)
 283   1        {
 284   2        case Timer1:
 285   2        {
 286   3          Timer4_Stop();
 287   3          Timer1_state = STOPPED;
 288   3      
 289   3        };
 290   2        break;
 291   2        case Timer2:
 292   2        {
 293   3          //    Timer3_Stop();//˴timer3timer2timer2ˣΪʹ    
 294   3          //    Timer2_state = STOPPED;
 295   3      
 296   3        };
 297   2        break;
 298   2        }
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 6   

 299   1      
 300   1      }
 301          //ʱδﵽʱʱ䷵1
 302          //************************************
 303          // Method:    isActiveTimer
 304          // FullName:  isActiveTimer
 305          // Access:    public 
 306          // Returns:   bit
 307          // Qualifier: ǰʱڶʱŷ1Ϊ0
 308          // Parameter: u8 whichTimer
 309          //************************************
 310          bit isActiveTimer(u8 whichTimer)
 311          {
 312   1        switch (whichTimer)
 313   1        {
 314   2        case Timer1:
 315   2        {
 316   3          return  Timer1_state == ACTIVE;
 317   3      
 318   3        };
 319   2        case Timer2:
 320   2        {
 321   3          return  Timer2_state == ACTIVE;
 322   3      
 323   3        };
 324   2        break;
 325   2        }
 326   1      }
 327          //ʱﵽ趨ʱʱ1
 328          //************************************
 329          // Method:    isExpiredTimer
 330          // FullName:  isExpiredTimer
 331          // Access:    public 
 332          // Returns:   bit
 333          // Qualifier: ʱĶʱʱѵ򷵻1
 334          // Parameter: u8 whichTimer
 335          //************************************
 336          bit isExpiredTimer(u8 whichTimer)
 337          {
 338   1        switch (whichTimer)
 339   1        {
 340   2        case Timer1:
 341   2        {
 342   3          return  Timer1_state == EXPIRED;
 343   3        };
 344   2        case Timer2:
 345   2        {
 346   3          return  Timer2_state == EXPIRED;
 347   3        };
 348   2        break;
 349   2        }
 350   1      
 351   1      
 352   1      }
 353          //ʱֹͣʱ1
 354          //************************************
 355          // Method:    isStopped
 356          // FullName:  isStopped
 357          // Access:    public 
 358          // Returns:   bit
 359          // Qualifier: ʱѾֹͣ򷵻1
 360          // Parameter: u8 whichtimer
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 7   

 361          //************************************
 362          bit isStopped(u8 whichtimer)
 363          {
 364   1        switch (whichtimer)
 365   1        {
 366   2        case Timer1:
 367   2        {
 368   3          return  Timer1_state == STOPPED;
 369   3        };
 370   2        case Timer2:
 371   2        {
 372   3          return  Timer2_state == STOPPED;
 373   3        };
 374   2        break;
 375   2        }
 376   1      }
 377          
 378          //
 379          //************************************
 380          // Method:    restartTimer
 381          // FullName:  restartTimer
 382          // Access:    public 
 383          // Returns:   void
 384          // Qualifier: ʼ򿪶ʱҪúöʱʱƵ
 385          // Parameter: u8 whichTimer
 386          //************************************
 387          void restartTimer(u8 whichTimer)
 388          {
 389   1        if (!isActiveTimer(whichTimer))
 390   1        {
 391   2          switch (whichTimer)
 392   2          {
 393   3          case Timer1:
 394   3          {
 395   4            Timer4_Run();
 396   4            Timer1_state = ACTIVE;
 397   4          };
 398   3          break;
 399   3          case Timer2:
 400   3          {
 401   4            //      Timer3_Run();
 402   4            //      Timer2_state = ACTIVE;
 403   4          };
 404   3          break;
 405   3          default:
 406   3            break;
 407   3          }
 408   2      
 409   2      
 410   2      
 411   2        }
 412   1      }
 413          //
 414          //************************************
 415          // Method:    onRestartTimer
 416          // FullName:  onRestartTimer
 417          // Access:    public 
 418          // Returns:   bit
 419          // Qualifier: ʱʱ󷵻1Զrestart¶ʱԴѭ
 420          // Parameter: u8 whichTimer
 421          //************************************
 422          bit onRestartTimer(u8 whichTimer)
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 8   

 423          {
 424   1        if (isExpiredTimer(whichTimer))
 425   1        {
 426   2          restartTimer(whichTimer);
 427   2          return TRUE;
 428   2        }
 429   1        else
 430   1        {
 431   2          return FALSE;
 432   2        }
 433   1      
 434   1      }
 435          
 436          
 437          //ȡӿ΢
 438          u16 getMicros(void)
 439          {
 440   1      
 441   1        return  micros;
 442   1      }
 443          //ȡӿĺ
 444          u16 getMillis(void)
 445          {
 446   1        return millis;
 447   1      }
 448          u8 getSeconds(void)
 449          {
 450   1        return seconds;
 451   1      }
 452          u8 getMinutes(void)
 453          {
 454   1        return minutes;
 455   1      }
 456          u8 getHours(void)
 457          {
 458   1        return hours;
 459   1      }
 460          u8 getDays(void)
 461          {
 462   1        return days;
 463   1      }
 464          
 465          //========================˽кҪ˽ҲҪĶκγ򣡣=================//
 466          /********************* Timer1жϺ************************/
 467          //static void Timer1_ISR(void) interrupt TIMER1_VECTOR
 468          //{
 469          
 470          //  if ((++Timer1_temp) >= timer1_struct.Timeout)
 471          //  {
 472          //    Timer1_Stop();
 473          //    Timer1_temp = 0;
 474          //    Timer1_state = EXPIRED;
 475          //  }
 476          
 477          
 478          
 479          //}
 480          
 481          // static void timer3_int(void) interrupt TIMER2_VECTOR
 482          //{
 483          //  if ((++Timer2_temp) >= 30)
 484          //  {
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 9   

 485          //    Timer2_Stop();
 486          //    Timer2_temp = 0;
 487          //    Timer2_state = EXPIRED;
 488          //  }
 489          
 490          //}
 491          
 492          /********************* Timer3жϺ************************/
 493          //static void timer3_int(void) interrupt TIMER3_VECTOR
 494          //{
 495          //  if ((++Timer2_temp) >= timer2_struct.Timeout)
 496          //  {
 497          //    Timer3_Stop();
 498          //    Timer2_temp = 0;
 499          //    Timer2_state = EXPIRED;
 500          //  }
 501          
 502          //}
 503          /********************* Timer4жϺ************************/
 504          //
 505          //sprintfʹòµʵֵûд
 506          //static void timer4_int(void) interrupt TIMER4_VECTOR
 507          //{
 508          
 509          
 510          //  EA = 0;
 511          //  if ((micros += 10) >= 1000)
 512          //  {
 513          //    micros = 0;
 514          //    if ((++millis) >= 1000)
 515          //    {
 516          //      millis = 0;
 517          //      if ((++seconds) >= 60)
 518          //      {
 519          //        seconds = 0;
 520          //        if ((++minutes) >= 60)
 521          //        {
 522          //          minutes = 0;
 523          //          if ((++hours) >= 24)
 524          //          {
 525          //            hours = 0;
 526          //            if ((++days) == UCHAR_MAX)
 527          //            {
 528          //              days = 0;
 529          //            }
 530          
 531          //          }
 532          //        }
 533          
 534          //      }
 535          //    }
 536          //  }
 537          
 538          //  EA = 1;
 539          //}
 540          /********************* Timer2жϺ************************/
 541          //˶ʱڵĶʱ
 542          //void Timer2_ISR (void) interrupt TIMER2_VECTOR
 543          //{
 544          //  
 545          //}
 546          
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 10  

 547          
 548          // : u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 549          // : ʱʼ.
 550          // : TIMx: ṹ,οtimer.hĶ.
 551          // : ɹ0, ղ1,󷵻2.
 552          // 汾: V1.0, 2012-10-22
 553          //========================================================================
 554          static u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 555          {
 556   1        if (TIM > Timer4) return 1; //ղ
 557   1      
 558   1        if (TIM == Timer0)
 559   1        {
 560   2          if (TIMx->TIM_Mode > TIM_16BitAutoReloadNoMask) return 2; //
 561   2          TR0 = 0;    //ֹͣ
 562   2          ET0 = 0;  //ֹж
 563   2          PT0 = 0;  //ȼж
 564   2          TMOD &= 0xf0; //ʱģʽ, 16λԶװ
 565   2          AUXR &= ~0x80;  //12Tģʽ, 
 566   2          INT_CLKO &= ~0x01;  //ʱ
 567   2          if (TIMx->TIM_Interrupt == ENABLE)    ET0 = 1;  //ж
 568   2          if (TIMx->TIM_Polity == PolityHigh)   PT0 = 1;  //ȼж
 569   2          TMOD |= TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ, 3: 16λԶװ, 
             -ж
 570   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x80; //1T
 571   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x04; //Ƶ
 572   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x01; //ʱ
 573   2      
 574   2          TH0 = (u8)(TIMx->TIM_Value >> 8);
 575   2          TL0 = (u8)TIMx->TIM_Value;
 576   2          if (TIMx->TIM_Run == ENABLE)  TR0 = 1;  //ʼ
 577   2          return  0;    //ɹ
 578   2        }
 579   1      
 580   1        if (TIM == Timer1)
 581   1        {
 582   2          TR1 = 0;    //ֹͣ
 583   2          if (TIMx->TIM_Interrupt == ENABLE)    ET1 = 1;  //ж
 584   2          else                  ET1 = 0;  //ֹж
 585   2          if (TIMx->TIM_Polity == PolityHigh)   PT1 = 1;  //ȼж
 586   2          else                  PT1 = 0;  //ȼж
 587   2          if (TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask)  return 2; //
 588   2          TMOD = (TMOD & ~0x30) | TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ
 589   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~0x40;  //12T
 590   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x40; //1T
 591   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x40; //Ƶ
 592   2          else                    TMOD &= ~0x40;  //ʱ
 593   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x02; //ʱ
 594   2          else              INT_CLKO &= ~0x02;  //ʱ
 595   2      
 596   2          TH1 = (u8)(TIMx->TIM_Value >> 8);
 597   2          TL1 = (u8)TIMx->TIM_Value;
 598   2          if (TIMx->TIM_Run == ENABLE)  TR1 = 1;  //ʼ
 599   2          return  0;    //ɹ
 600   2        }
 601   1      
 602   1        if (TIM == Timer2)    //Timer2,̶Ϊ16λԶװ, жȼ
 603   1        {
 604   2          AUXR &= ~(1 << 4);  //ֹͣ
 605   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 2);  //ж
 606   2          else                    IE2 &= ~(1 << 2); //ֹж
 607   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
C51 COMPILER V8.05a   TIMER                                                                07/30/2017 21:36:00 PAGE 11  

 608   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~(1 << 2);  //12T
 609   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= (1 << 2); //1T
 610   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) AUXR |= (1 << 3); //Ƶ
 611   2          else                    AUXR &= ~(1 << 3);  //ʱ
 612   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x04; //ʱ
 613   2          else              INT_CLKO &= ~0x04;  //ʱ
 614   2      
 615   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 616   2          TL2 = (u8)TIMx->TIM_Value;
 617   2          if (TIMx->TIM_Run == ENABLE)  AUXR |= (1 << 4); //ʼ
 618   2          return  0;    //ɹ
 619   2        }
 620   1      
 621   1        if (TIM == Timer3)    //Timer3,̶Ϊ16λԶװ, жȼ
 622   1        {
 623   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 624   2          T4T3M &= 0xf0;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 625   2          IE2 &= ~(1 << 5); //ֹж
 626   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 5);  //ж
 627   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 1);  //1T
 628   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 1);  //Ƶ
 629   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= 1; //ʱ
 630   2      
 631   2          TH3 = (u8)(TIMx->TIM_Value >> 8);
 632   2          TL3 = (u8)TIMx->TIM_Value;
 633   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 3);  //ʼ
 634   2          return  0;    //ɹ
 635   2        }
 636   1      
 637   1        if (TIM == Timer4)    //Timer4,̶Ϊ16λԶװ, жȼ
 638   1        {
 639   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 640   2          T4T3M &= 0x0f;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 641   2          IE2 &= ~(1 << 6); //ֹж
 642   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 6);  //ж
 643   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 5);  //1T
 644   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 5);  //Ƶ
 645   2      
 646   2          TH4 = (u8)(TIMx->TIM_Value >> 8);
 647   2          TL4 = (u8)TIMx->TIM_Value;
 648   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 7);  //ʼ
 649   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= (1 << 4);  //ʱ
 650   2      
 651   2          return  0;    //ɹ
 652   2        }
 653   1      
 654   1        return 2; //
 655   1      }
 656          
 657          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    976    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
