C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\COMMON_HARDWARE\BSP\timer\timer.c LARGE WARNINGLEVEL(0) BROW
                    -SE DEBUG OBJECTEXTEND PRINT(.\timer.lst) TABS(2) OBJECT(.\timer.obj)

line level    source

   1          /************************************************************
   2          * ļ: timer.c
   3          * : ܳ
   4          * 汾: 1.0
   5          * : 2017/4/29
   6          * : 嵥ƬƬ϶ʱʹá
   7          * Ҫ书 :
   8          * ʷ޸ļ¼:
   9          * <> <ʱ> <汾 > <>
  10          * ܳ 2017/4/29 ˴ļ˵ע
  11          * ܳ 2017/7/27 1.2 ˶ʱʹãڵĶʱ£
  12          * Timer 0 OS
  13          * Timer 1 1
  14          * Timer 2 pulser1
  15          * Timer 3 pulser2
  16          * Timer 4 ûʱ //ʱ޷ʹ
  17          * osʹʱʹãʱ
  18          * ⣬Էֳtimer4 ĸ޷ʹĶʱ
  19          * Ҫעʹõʱtimer2ĸǴ1 rxţصʱ뾡ôŲҪ
  20          * ܻʧ
  21          ***********************************************************/
  22          //////////////////////ʱӦ/////////////////////////////////////// 
  23          /*
  24          
  25          
  26                  setTimeout(Timer1,5000); //öʱʱ ,5
  27                                restartTimer(Timer1);
  28          
  29                  while(1)
  30                  {
  31                    if(isExpiredTimer(Timer1))   //ﵽʱʱ
  32                    {
  33                       stopTimer(Timer1);//ﵽʱʱһҪرնʱ޷ظʹöʱ
  34                      //ʱʱ䵽Ĵд
  35                    }
  36                    else//δﵽʱʱʱδ
  37                    {
  38          
  39          
  40          
  41          
  42                    }
  43                  }
  44          */
  45          ///////////////////////////////////////////////////////////////
  46          #include <limits.h>
  47          #include <assert.h>
  48          #include <stdlib.h>
  49          #include <stdio.h>
  50          
  51          
  52          #include  "timer.h"
  53          #include "../USART1/USART1.h"
  54          enum
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 2   

  55          {
  56            STOPPED, EXPIRED, ACTIVE
  57          }
  58          Timer1_state = STOPPED,
  59          Timer2_state = STOPPED;
  60          
  61          static u16 Timer1_temp = 0;
  62          static u16 Timer2_temp = 0;
  63          static u16 micros = 0;//ʱȡ
  64          static u16 millis = 0;//ʱȡ
  65          static u8 seconds = 0;
  66          static u8 minutes = 0;
  67          static u8 hours = 0;
  68          static u8 days = 0;
  69          
  70          
  71          
  72          
  73          struct TimerInfo
  74          {
  75            u16 Timeout;
  76            u16 Hz;
  77          }
  78          timer1_struct = { 0,0 },
  79          timer2_struct = { 0,0 };
  80          //************************************
  81          // Method:    timerInit
  82          // FullName:  timerInit
  83          // Access:    public 
  84          // Returns:   void
  85          // Qualifier: ʱʼʹûʱ;ʱȡ֮ǰsetupеô˺ɳʼ
  86          //************************************
  87          void timerInit()
  88          {
  89   1        TIM_InitTypeDef   USER_Timer; //ûԶ嶨ʱʹ
  90   1        TIM_InitTypeDef   Pulser_1_Timer; //
  91   1        TIM_InitTypeDef   Pulser_2_Timer;
  92   1        u8 Error_Code = 0;
  93   1        //  
  94   1        //    //ûԶ嶨ʱ    
  95   1        USER_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ    TIM_16BitAutoReload,TIM_16B
             -it,TIM_8BitAutoReload,\\                                                                                                                TIM_16BitAutoReloadNoMask
  96   1        USER_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
  97   1        USER_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
  98   1        USER_Timer.TIM_ClkSource = TIM_CLOCK_1T;  //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
  99   1        USER_Timer.TIM_ClkOut = DISABLE;        //Ƿ, ENABLEDISABLE
 100   1        USER_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 101   1        USER_Timer.TIM_Value = 65536UL - (MAIN_Fosc / 1000);    //ֵ,1000us
 102   1        //巢1Ķʱ
 103   1        Pulser_1_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload,\\                                                                                                                   TIM_16BitAutoReloadNoMask
 104   1        Pulser_1_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 105   1        Pulser_1_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 106   1        Pulser_1_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 107   1        //Pulser_1_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 108   1        Pulser_1_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 109   1      
 110   1        //巢2Ķʱ
 111   1        Pulser_2_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload                                                                                                                                            //TIM_16BitAutoReloadNoMa
             -sk
 112   1        Pulser_2_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 3   

 113   1        Pulser_2_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 114   1        Pulser_2_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 115   1        //Pulser_2_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 116   1        Pulser_2_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 117   1        Timer_Inilize(Timer4, &USER_Timer);
 118   1        Timer_Inilize(Timer2, &Pulser_1_Timer);
 119   1        Timer_Inilize(Timer3, &Pulser_2_Timer);
 120   1        //    //ûԶ嶨ʱ    
 121   1      //  if (!(Error_Code = Timer_Inilize(Timer4, &USER_Timer)))//==0
 122   1      //  {
 123   1      //    //PrintString1("USER_Timer initializing succeed \r\n");
 124   1      //  }
 125   1      //  else if (Error_Code) //==1
 126   1      //  {
 127   1      //    //PrintString1("USER_Timer initializing failed \r\n");
 128   1      //  }
 129   1      //  else
 130   1      //  {
 131   1      //    //PrintString1("USER_Timer initializing failed \r\n");
 132   1      //  }
 133   1      
 134   1        //  //巢1Ķʱ
 135   1        //  if (!(Error_Code = Timer_Inilize(Timer1, &TIM_InitStructure)))//==0
 136   1        //  {
 137   1        //    //PrintString1("Pulser_1_Timer initializing succeed \r\n" );
 138   1        //  }
 139   1        //  else if (Error_Code) //==1
 140   1        //  {
 141   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 142   1        //  }
 143   1        //  else
 144   1        //  {
 145   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 146   1        //  }
 147   1        //  //巢2Ķʱ
 148   1        //  if (!(Error_Code = Timer_Inilize(Timer3, &Pulser_2_Timer)))//==0
 149   1        //  {
 150   1        //    //PrintString1("Pulser_2_Timer initializing succeed \r\n");
 151   1        //  }
 152   1        //  else if (Error_Code) //==1
 153   1        //  {
 154   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 155   1        //  }
 156   1        //  else
 157   1        //  {
 158   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 159   1        //  }
 160   1      
 161   1      
 162   1      
 163   1      }
 164          
 165          //
 166          //************************************
 167          // Method:    setTimeout
 168          // FullName:  setTimeout
 169          // Access:    public 
 170          // Returns:   void
 171          // Qualifier: öʱĶʱʱ
 172          // Parameter: u8 whichTimerһʱ
 173          // Parameter: u16 timeҪʱʱ䣬λms
 174          //************************************
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 4   

 175          void setTimeout(u8 whichTimer, u16 time)
 176          {
 177   1        if (!(Timer1_state == ACTIVE || Timer2_state == ACTIVE))
 178   1        {
 179   2          switch (whichTimer)
 180   2          {
 181   3      
 182   3          case Timer1:
 183   3          {
 184   4            timer1_struct.Timeout = time;
 185   4            //  Timer1_state = EXPIRED;
 186   4      
 187   4        //  PrintString1("set timeout\r\n");
 188   4          };
 189   3          case Timer2:
 190   3          {
 191   4            timer2_struct.Timeout = time;
 192   4          };
 193   3          default:
 194   3            break;
 195   3          }
 196   2        }
 197   1      }
 198          //************************************
 199          // Method:    getTimerout
 200          // FullName:  getTimerout
 201          // Access:    public 
 202          // Returns:   u16
 203          // Qualifier:
 204          // Parameter: u8 whichTimer
 205          //************************************
 206          u16 getTimerout(u8 whichTimer)
 207          {
 208   1        switch (whichTimer)
 209   1        {
 210   2      
 211   2        case Timer1:
 212   2        {
 213   3          return timer1_struct.Timeout;
 214   3        };
 215   2        break;
 216   2        case Timer2:
 217   2        {
 218   3          return timer2_struct.Timeout;
 219   3        };
 220   2        break;
 221   2      
 222   2        default: return 0;
 223   2        }
 224   1      
 225   1      }
 226          //
 227          //************************************
 228          // Method:    setTimerHertz
 229          // FullName:  setTimerHertz
 230          // Access:    public 
 231          // Returns:   void
 232          // Qualifier: öʱķƵ
 233          // Parameter: u8 whichTimerһʱ
 234          // Parameter: u16 HzƵ
 235          //************************************
 236          void setTimerHertz(u8 whichTimer, u16 Hz)
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 5   

 237          {
 238   1        switch (whichTimer)
 239   1        {
 240   2      
 241   2        case Timer1:
 242   2        {
 243   3          timer1_struct.Hz = Hz;
 244   3        };
 245   2        break;
 246   2        case Timer2:
 247   2        {
 248   3          timer2_struct.Hz = Hz;
 249   3        };
 250   2        break;
 251   2      
 252   2        }
 253   1      
 254   1      
 255   1      }
 256          u16 getTimerHertz(u8 whichTimer)
 257          {
 258   1        switch (whichTimer)
 259   1        {
 260   2      
 261   2          break;
 262   2        case Timer1:
 263   2        {
 264   3          return timer1_struct.Hz;
 265   3        };
 266   2        break;
 267   2        case Timer2:
 268   2        {
 269   3          return timer2_struct.Hz;
 270   3        };
 271   2        break;
 272   2        default: return 0;
 273   2        }
 274   1      }
 275          //ͣöʱ
 276          //************************************
 277          // Method:    stopTimer
 278          // FullName:  stopTimer
 279          // Access:    public 
 280          // Returns:   void
 281          // Qualifier: ֹͣӦĶʱ
 282          // Parameter: u8 whichTimer
 283          //************************************
 284          void stopTimer(u8 whichTimer)
 285          {
 286   1        switch (whichTimer)
 287   1        {
 288   2        case Timer1:
 289   2        {
 290   3          Timer4_Stop();
 291   3          Timer1_state = STOPPED;
 292   3      
 293   3        };
 294   2        break;
 295   2        case Timer2:
 296   2        {
 297   3          //    Timer3_Stop();//˴timer3timer2timer2ˣΪʹ    
 298   3          //    Timer2_state = STOPPED;
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 6   

 299   3      
 300   3        };
 301   2        break;
 302   2        }
 303   1      
 304   1      }
 305          //ʱδﵽʱʱ䷵1
 306          //************************************
 307          // Method:    isActiveTimer
 308          // FullName:  isActiveTimer
 309          // Access:    public 
 310          // Returns:   bit
 311          // Qualifier: ǰʱڶʱŷ1Ϊ0
 312          // Parameter: u8 whichTimer
 313          //************************************
 314          bit isActiveTimer(u8 whichTimer)
 315          {
 316   1        switch (whichTimer)
 317   1        {
 318   2        case Timer1:
 319   2        {
 320   3          return  Timer1_state == ACTIVE;
 321   3      
 322   3        };
 323   2        case Timer2:
 324   2        {
 325   3          return  Timer2_state == ACTIVE;
 326   3      
 327   3        };
 328   2        break;
 329   2        }
 330   1      }
 331          //ʱﵽ趨ʱʱ1
 332          //************************************
 333          // Method:    isExpiredTimer
 334          // FullName:  isExpiredTimer
 335          // Access:    public 
 336          // Returns:   bit
 337          // Qualifier: ʱĶʱʱѵ򷵻1
 338          // Parameter: u8 whichTimer
 339          //************************************
 340          bit isExpiredTimer(u8 whichTimer)
 341          {
 342   1        switch (whichTimer)
 343   1        {
 344   2        case Timer1:
 345   2        {
 346   3          return  Timer1_state == EXPIRED;
 347   3        };
 348   2        case Timer2:
 349   2        {
 350   3          return  Timer2_state == EXPIRED;
 351   3        };
 352   2        break;
 353   2        }
 354   1      
 355   1      
 356   1      }
 357          //ʱֹͣʱ1
 358          //************************************
 359          // Method:    isStopped
 360          // FullName:  isStopped
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 7   

 361          // Access:    public 
 362          // Returns:   bit
 363          // Qualifier: ʱѾֹͣ򷵻1
 364          // Parameter: u8 whichtimer
 365          //************************************
 366          bit isStopped(u8 whichtimer)
 367          {
 368   1        switch (whichtimer)
 369   1        {
 370   2        case Timer1:
 371   2        {
 372   3          return  Timer1_state == STOPPED;
 373   3        };
 374   2        case Timer2:
 375   2        {
 376   3          return  Timer2_state == STOPPED;
 377   3        };
 378   2        break;
 379   2        }
 380   1      }
 381          
 382          //
 383          //************************************
 384          // Method:    restartTimer
 385          // FullName:  restartTimer
 386          // Access:    public 
 387          // Returns:   void
 388          // Qualifier: ʼ򿪶ʱҪúöʱʱƵ
 389          // Parameter: u8 whichTimer
 390          //************************************
 391          void restartTimer(u8 whichTimer)
 392          {
 393   1        if (!isActiveTimer(whichTimer))
 394   1        {
 395   2          switch (whichTimer)
 396   2          {
 397   3          case Timer1:
 398   3          {
 399   4            Timer4_Run();
 400   4            Timer1_state = ACTIVE;
 401   4            //    Timer1_state = EXPIRED;
 402   4            //    PrintString1("timer 1 is expired\r\n");
 403   4      
 404   4          };
 405   3          break;
 406   3          case Timer2:
 407   3          {
 408   4            //      Timer3_Run();
 409   4            //      Timer2_state = ACTIVE;
 410   4          };
 411   3          break;
 412   3          default:
 413   3            break;
 414   3          }
 415   2      
 416   2      
 417   2      
 418   2        }
 419   1      }
 420          //
 421          //************************************
 422          // Method:    onRestartTimer
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 8   

 423          // FullName:  onRestartTimer
 424          // Access:    public 
 425          // Returns:   bit
 426          // Qualifier: ʱʱ󷵻1Զrestart¶ʱԴѭ
 427          // Parameter: u8 whichTimer
 428          //************************************
 429          bit onRestartTimer(u8 whichTimer)
 430          {
 431   1        if (isExpiredTimer(whichTimer))
 432   1        {
 433   2          restartTimer(whichTimer);
 434   2          return TRUE;
 435   2        }
 436   1        else
 437   1        {
 438   2          return FALSE;
 439   2        }
 440   1      
 441   1      }
 442          
 443          
 444          //ȡӿ΢
 445          u16 getMicros(void)
 446          {
 447   1      
 448   1        return  micros;
 449   1      }
 450          //ȡӿĺ
 451          u16 getMillis(void)
 452          {
 453   1        return millis;
 454   1      }
 455          u8 getSeconds(void)
 456          {
 457   1        return seconds;
 458   1      }
 459          u8 getMinutes(void)
 460          {
 461   1        return minutes;
 462   1      }
 463          u8 getHours(void)
 464          {
 465   1        return hours;
 466   1      }
 467          u8 getDays(void)
 468          {
 469   1        return days;
 470   1      }
 471          
 472          
 473          //========================˽кҪ˽ҲҪĶκγ򣡣=================//
 474          /********************* Timer4жϺ************************/
 475          static void timer4_int(void) interrupt TIMER4_VECTOR
 476          {
 477   1      
 478   1      
 479   1        if ((++Timer1_temp) >= timer1_struct.Timeout)
 480   1        {
 481   2      
 482   2          Timer4_Stop();
 483   2      
 484   2          Timer1_temp = 0;
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 9   

 485   2          Timer1_state = EXPIRED;
 486   2        }
 487   1      
 488   1      }
 489          
 490          /********************* Timer1жϺ************************/
 491          //static void Timer1_ISR(void) interrupt TIMER1_VECTOR
 492          //{
 493          
 494          //  if ((++Timer1_temp) >= timer1_struct.Timeout)
 495          //  {
 496          //    Timer1_Stop();
 497          //    Timer1_temp = 0;
 498          //    Timer1_state = EXPIRED;
 499          //  }
 500          
 501          
 502          
 503          //}
 504          
 505          // static void timer3_int(void) interrupt TIMER2_VECTOR
 506          //{
 507          //  if ((++Timer2_temp) >= 30)
 508          //  {
 509          //    Timer2_Stop();
 510          //    Timer2_temp = 0;
 511          //    Timer2_state = EXPIRED;
 512          //  }
 513          
 514          //}
 515          
 516          /********************* Timer4жϺ************************/
 517          //
 518          //sprintfʹòµʵֵûд
 519          //static void timer4_int(void) interrupt TIMER4_VECTOR
 520          //{
 521          
 522          
 523          //  EA = 0;
 524          //  if ((micros += 10) >= 1000)
 525          //  {
 526          //    micros = 0;
 527          //    if ((++millis) >= 1000)
 528          //    {
 529          //      millis = 0;
 530          //      if ((++seconds) >= 60)
 531          //      {
 532          //        seconds = 0;
 533          //        if ((++minutes) >= 60)
 534          //        {
 535          //          minutes = 0;
 536          //          if ((++hours) >= 24)
 537          //          {
 538          //            hours = 0;
 539          //            if ((++days) == UCHAR_MAX)
 540          //            {
 541          //              days = 0;
 542          //            }
 543          
 544          //          }
 545          //        }
 546          
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 10  

 547          //      }
 548          //    }
 549          //  }
 550          
 551          //  EA = 1;
 552          //}
 553          /********************* Timer2жϺ************************/
 554          //˶ʱڵĶʱ
 555          //void Timer2_ISR (void) interrupt TIMER2_VECTOR
 556          //{
 557          //  
 558          //}
 559          
 560          
 561          // : u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 562          // : ʱʼ.
 563          // : TIMx: ṹ,οtimer.hĶ.
 564          // : ɹ0, ղ1,󷵻2.
 565          // 汾: V1.0, 2012-10-22
 566          //========================================================================
 567          static u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 568          {
 569   1        if (TIM > Timer4) return 1; //ղ
 570   1      
 571   1        if (TIM == Timer0)
 572   1        {
 573   2          if (TIMx->TIM_Mode > TIM_16BitAutoReloadNoMask) return 2; //
 574   2          TR0 = 0;    //ֹͣ
 575   2          ET0 = 0;  //ֹж
 576   2          PT0 = 0;  //ȼж
 577   2          TMOD &= 0xf0; //ʱģʽ, 16λԶװ
 578   2          AUXR &= ~0x80;  //12Tģʽ, 
 579   2          INT_CLKO &= ~0x01;  //ʱ
 580   2          if (TIMx->TIM_Interrupt == ENABLE)    ET0 = 1;  //ж
 581   2          if (TIMx->TIM_Polity == PolityHigh)   PT0 = 1;  //ȼж
 582   2          TMOD |= TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ, 3: 16λԶװ, 
             -ж
 583   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x80; //1T
 584   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x04; //Ƶ
 585   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x01; //ʱ
 586   2      
 587   2          TH0 = (u8)(TIMx->TIM_Value >> 8);
 588   2          TL0 = (u8)TIMx->TIM_Value;
 589   2          if (TIMx->TIM_Run == ENABLE)  TR0 = 1;  //ʼ
 590   2          return  0;    //ɹ
 591   2        }
 592   1      
 593   1        if (TIM == Timer1)
 594   1        {
 595   2          TR1 = 0;    //ֹͣ
 596   2          if (TIMx->TIM_Interrupt == ENABLE)    ET1 = 1;  //ж
 597   2          else                  ET1 = 0;  //ֹж
 598   2          if (TIMx->TIM_Polity == PolityHigh)   PT1 = 1;  //ȼж
 599   2          else                  PT1 = 0;  //ȼж
 600   2          if (TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask)  return 2; //
 601   2          TMOD = (TMOD & ~0x30) | TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ
 602   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~0x40;  //12T
 603   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x40; //1T
 604   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x40; //Ƶ
 605   2          else                    TMOD &= ~0x40;  //ʱ
 606   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x02; //ʱ
 607   2          else              INT_CLKO &= ~0x02;  //ʱ
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 11  

 608   2      
 609   2          TH1 = (u8)(TIMx->TIM_Value >> 8);
 610   2          TL1 = (u8)TIMx->TIM_Value;
 611   2          if (TIMx->TIM_Run == ENABLE)  TR1 = 1;  //ʼ
 612   2          return  0;    //ɹ
 613   2        }
 614   1      
 615   1        if (TIM == Timer2)    //Timer2,̶Ϊ16λԶװ, жȼ
 616   1        {
 617   2          AUXR &= ~(1 << 4);  //ֹͣ
 618   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 2);  //ж
 619   2          else                    IE2 &= ~(1 << 2); //ֹж
 620   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 621   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~(1 << 2);  //12T
 622   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= (1 << 2); //1T
 623   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) AUXR |= (1 << 3); //Ƶ
 624   2          else                    AUXR &= ~(1 << 3);  //ʱ
 625   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x04; //ʱ
 626   2          else              INT_CLKO &= ~0x04;  //ʱ
 627   2      
 628   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 629   2          TL2 = (u8)TIMx->TIM_Value;
 630   2          if (TIMx->TIM_Run == ENABLE)  AUXR |= (1 << 4); //ʼ
 631   2          return  0;    //ɹ
 632   2        }
 633   1      
 634   1        if (TIM == Timer3)    //Timer3,̶Ϊ16λԶװ, жȼ
 635   1        {
 636   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 637   2          T4T3M &= 0xf0;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 638   2          IE2 &= ~(1 << 5); //ֹж
 639   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 5);  //ж
 640   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 1);  //1T
 641   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 1);  //Ƶ
 642   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= 1; //ʱ
 643   2      
 644   2          TH3 = (u8)(TIMx->TIM_Value >> 8);
 645   2          TL3 = (u8)TIMx->TIM_Value;
 646   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 3);  //ʼ
 647   2          return  0;    //ɹ
 648   2        }
 649   1      
 650   1        if (TIM == Timer4)    //Timer4,̶Ϊ16λԶװ, жȼ
 651   1        {
 652   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 653   2          T4T3M &= 0x0f;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 654   2          IE2 &= ~(1 << 6); //ֹж
 655   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 6);  //ж
 656   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 5);  //1T
 657   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 5);  //Ƶ
 658   2      
 659   2          TH4 = (u8)(TIMx->TIM_Value >> 8);
 660   2          TL4 = (u8)TIMx->TIM_Value;
 661   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 7);  //ʼ
 662   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= (1 << 4);  //ʱ
 663   2      
 664   2          return  0;    //ɹ
 665   2        }
 666   1      
 667   1        return 2; //
 668   1      }
 669          
C51 COMPILER V8.05a   TIMER                                                                08/02/2017 11:51:05 PAGE 12  

 670          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1065    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
