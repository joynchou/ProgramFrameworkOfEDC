C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\COMMON_HARDWARE\BSP\timer\timer.c LARGE WARNINGLEVEL(0) BROW
                    -SE DEBUG OBJECTEXTEND PRINT(.\timer.lst) TABS(2) OBJECT(.\timer.obj)

line level    source

   1          /************************************************************
   2          * ļ: timer.c
   3          * : ܳ
   4          * 汾: 1.0
   5          * : 2017/4/29
   6          * : 嵥ƬƬ϶ʱʹá
   7          * Ҫ书 :
   8          * ʷ޸ļ¼:
   9          * <> <ʱ> <汾 > <>
  10          * ܳ 2017/4/29 ˴ļ˵ע
  11          * ܳ 2017/7/27 1.2 ˶ʱʹãڵĶʱ£
  12          * Timer 0 OS
  13          * Timer 1 1
  14          * Timer 2 pulser1
  15          * Timer 3 pulser2
  16          * Timer 4 ûʱ //ʱ޷ʹ
  17          * osʹʱʹãʱ
  18          * ⣬Էֳtimer4 ĸ޷ʹĶʱ
  19          * Ҫעʹõʱtimer2ĸǴ1 rxţصʱ뾡ôŲҪ
  20          * ܻʧ
  21          ***********************************************************/
  22          //////////////////////ʱӦ/////////////////////////////////////// 
  23          /*
  24          
  25          
  26                  setTimeout(Timer1,5000); //öʱʱ ,5
  27                  while(1)
  28                  {
  29                    if(isExpiredTimer(Timer1))   //ﵽʱʱ
  30                    {
  31                       stopTimer(Timer1);//ﵽʱʱһҪرնʱ޷ظʹöʱ
  32                      //ʱʱ䵽Ĵд
  33                    }
  34                    else//δﵽʱʱʱδ
  35                    {
  36          
  37          
  38                        restartTimer(Timer1);
  39          
  40          
  41                    }
  42                  }
  43          */
  44          ///////////////////////////////////////////////////////////////
  45          #include <limits.h>
  46          #include <assert.h>
  47          #include <stdlib.h>
  48          #include <stdio.h>
  49          
  50          
  51          #include  "timer.h"
  52          #include "../USART1/USART1.h"
  53          enum
  54          {
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 2   

  55            STOPPED,EXPIRED,ACTIVE 
  56          }
  57          Timer1_state = STOPPED,
  58          Timer2_state = STOPPED;
  59          
  60          static u16 Timer1_temp = 0;
  61          static u16 Timer2_temp = 0;
  62          static u16 micros = 0;//ʱȡ
  63          static u16 millis = 0;//ʱȡ
  64          static u8 seconds = 0;
  65          static u8 minutes = 0;
  66          static u8 hours = 0;
  67          static u8 days = 0;
  68          
  69          
  70          
  71          
  72          struct TimerInfo
  73          {
  74            u16 Timeout;
  75            u16 Hz;
  76          }
  77          timer1_struct = { 0,0 },
  78          timer2_struct = { 0,0 };
  79          //************************************
  80          // Method:    timerInit
  81          // FullName:  timerInit
  82          // Access:    public 
  83          // Returns:   void
  84          // Qualifier: ʱʼʹûʱ;ʱȡ֮ǰsetupеô˺ɳʼ
  85          //************************************
  86          void timerInit()
  87          {
  88   1        TIM_InitTypeDef   USER_Timer; //ûԶ嶨ʱʹ
  89   1        TIM_InitTypeDef   Pulser_1_Timer; //
  90   1        TIM_InitTypeDef   Pulser_2_Timer;
  91   1        u8 Error_Code = 0;
  92   1        //  
  93   1        //    //ûԶ嶨ʱ    
  94   1        USER_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ    TIM_16BitAutoReload,TIM_16B
             -it,TIM_8BitAutoReload,\\                                                                                                                TIM_16BitAutoReloadNoMask
  95   1        USER_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
  96   1        USER_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
  97   1        USER_Timer.TIM_ClkSource = TIM_CLOCK_1T;  //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
  98   1        USER_Timer.TIM_ClkOut = DISABLE;        //Ƿ, ENABLEDISABLE
  99   1        USER_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 100   1        USER_Timer.TIM_Value = 65536UL - (MAIN_Fosc / 1000);    //ֵ,1000us
 101   1        //巢1Ķʱ
 102   1        Pulser_1_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload,\\                                                                                                                   TIM_16BitAutoReloadNoMask
 103   1        Pulser_1_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 104   1        Pulser_1_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
 105   1        Pulser_1_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 106   1        //Pulser_1_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 107   1        Pulser_1_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 108   1      
 109   1        //巢2Ķʱ
 110   1        Pulser_2_Timer.TIM_Mode = TIM_16BitAutoReload;  //ָģʽ,16λԶװģʽ   TIM_16BitAutoReload,TIM_
             -16Bit,TIM_8BitAutoReload                                                                                                                                            //TIM_16BitAutoReloadNoMa
             -sk
 111   1        Pulser_2_Timer.TIM_Polity = PolityHigh;     //ָжȼ, PolityHigh,PolityLow
 112   1        Pulser_2_Timer.TIM_Interrupt = ENABLE;        //жǷ,   ENABLEDISABLE
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 3   

 113   1        Pulser_2_Timer.TIM_ClkSource = TIM_CLOCK_12T; //ָʱԴ,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
 114   1        //Pulser_2_Timer.TIM_ClkOut = ENABLE;       //Ƿ, ENABLEDISABLE
 115   1        Pulser_2_Timer.TIM_Run = DISABLE;       //Ƿʼʱ, ENABLEDISABLE
 116   1        Timer_Inilize(Timer4, &USER_Timer); 
 117   1        Timer_Inilize(Timer2, &Pulser_1_Timer);
 118   1        Timer_Inilize(Timer3, &Pulser_2_Timer);
 119   1        //    //ûԶ嶨ʱ    
 120   1      //  if (!(Error_Code = Timer_Inilize(Timer4, &USER_Timer)))//==0
 121   1      //  {
 122   1      //    //PrintString1("USER_Timer initializing succeed \r\n");
 123   1      //  }
 124   1      //  else if (Error_Code) //==1
 125   1      //  {
 126   1      //    //PrintString1("USER_Timer initializing failed \r\n");
 127   1      //  }
 128   1      //  else
 129   1      //  {
 130   1      //    //PrintString1("USER_Timer initializing failed \r\n");
 131   1      //  }
 132   1      
 133   1        //  //巢1Ķʱ
 134   1        //  if (!(Error_Code = Timer_Inilize(Timer1, &TIM_InitStructure)))//==0
 135   1        //  {
 136   1        //    //PrintString1("Pulser_1_Timer initializing succeed \r\n" );
 137   1        //  }
 138   1        //  else if (Error_Code) //==1
 139   1        //  {
 140   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 141   1        //  }
 142   1        //  else
 143   1        //  {
 144   1        //    //PrintString1("Pulser_1_Timer initializing failed \r\n");
 145   1        //  }
 146   1        //  //巢2Ķʱ
 147   1        //  if (!(Error_Code = Timer_Inilize(Timer3, &Pulser_2_Timer)))//==0
 148   1        //  {
 149   1        //    //PrintString1("Pulser_2_Timer initializing succeed \r\n");
 150   1        //  }
 151   1        //  else if (Error_Code) //==1
 152   1        //  {
 153   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 154   1        //  }
 155   1        //  else
 156   1        //  {
 157   1        //    //PrintString1("Pulser_2_Timer initializing failed \r\n");
 158   1        //  }
 159   1      
 160   1      
 161   1      
 162   1      }
 163          
 164          //
 165          //************************************
 166          // Method:    setTimeout
 167          // FullName:  setTimeout
 168          // Access:    public 
 169          // Returns:   void
 170          // Qualifier: öʱĶʱʱ
 171          // Parameter: u8 whichTimerһʱ
 172          // Parameter: u16 timeҪʱʱ䣬λms
 173          //************************************
 174          void setTimeout(u8 whichTimer, u16 time)
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 4   

 175          {
 176   1        if (!(Timer1_state == ACTIVE || Timer2_state == ACTIVE))
 177   1        {
 178   2          switch (whichTimer)
 179   2          {
 180   3      
 181   3          case Timer1:
 182   3          {
 183   4            timer1_struct.Timeout = time;
 184   4              //  Timer1_state = EXPIRED;
 185   4      
 186   4          //  PrintString1("set timeout\r\n");
 187   4          };
 188   3          case Timer2:
 189   3          {
 190   4            timer2_struct.Timeout = time;
 191   4          };
 192   3          default:
 193   3            break;
 194   3          }
 195   2        }
 196   1      }
 197          //************************************
 198          // Method:    getTimerout
 199          // FullName:  getTimerout
 200          // Access:    public 
 201          // Returns:   u16
 202          // Qualifier:
 203          // Parameter: u8 whichTimer
 204          //************************************
 205          u16 getTimerout(u8 whichTimer)
 206          {
 207   1        switch (whichTimer)
 208   1        {
 209   2      
 210   2        case Timer1:
 211   2        {
 212   3          return timer1_struct.Timeout;
 213   3        };
 214   2        break;
 215   2        case Timer2:
 216   2        {
 217   3          return timer2_struct.Timeout;
 218   3        };
 219   2        break;
 220   2      
 221   2        default: return 0;
 222   2        }
 223   1      
 224   1      }
 225          //
 226          //************************************
 227          // Method:    setTimerHertz
 228          // FullName:  setTimerHertz
 229          // Access:    public 
 230          // Returns:   void
 231          // Qualifier: öʱķƵ
 232          // Parameter: u8 whichTimerһʱ
 233          // Parameter: u16 HzƵ
 234          //************************************
 235          void setTimerHertz(u8 whichTimer, u16 Hz)
 236          {
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 5   

 237   1        switch (whichTimer)
 238   1        {
 239   2      
 240   2        case Timer1:
 241   2        {
 242   3          timer1_struct.Hz = Hz;
 243   3        };
 244   2        break;
 245   2        case Timer2:
 246   2        {
 247   3          timer2_struct.Hz = Hz;
 248   3        };
 249   2        break;
 250   2      
 251   2        }
 252   1      
 253   1      
 254   1      }
 255          u16 getTimerHertz(u8 whichTimer)
 256          {
 257   1        switch (whichTimer)
 258   1        {
 259   2      
 260   2          break;
 261   2        case Timer1:
 262   2        {
 263   3          return timer1_struct.Hz;
 264   3        };
 265   2        break;
 266   2        case Timer2:
 267   2        {
 268   3          return timer2_struct.Hz;
 269   3        };
 270   2        break;
 271   2        default: return 0;
 272   2        }
 273   1      }
 274          //ͣöʱ
 275          //************************************
 276          // Method:    stopTimer
 277          // FullName:  stopTimer
 278          // Access:    public 
 279          // Returns:   void
 280          // Qualifier: ֹͣӦĶʱ
 281          // Parameter: u8 whichTimer
 282          //************************************
 283          void stopTimer(u8 whichTimer)
 284          {
 285   1        switch (whichTimer)
 286   1        {
 287   2        case Timer1:
 288   2        {
 289   3          Timer4_Stop();
 290   3          Timer1_state = STOPPED;
 291   3      
 292   3        };
 293   2        break;
 294   2        case Timer2:
 295   2        {
 296   3          //    Timer3_Stop();//˴timer3timer2timer2ˣΪʹ    
 297   3          //    Timer2_state = STOPPED;
 298   3      
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 6   

 299   3        };
 300   2        break;
 301   2        }
 302   1      
 303   1      }
 304          //ʱδﵽʱʱ䷵1
 305          //************************************
 306          // Method:    isActiveTimer
 307          // FullName:  isActiveTimer
 308          // Access:    public 
 309          // Returns:   bit
 310          // Qualifier: ǰʱڶʱŷ1Ϊ0
 311          // Parameter: u8 whichTimer
 312          //************************************
 313          bit isActiveTimer(u8 whichTimer)
 314          {
 315   1        switch (whichTimer)
 316   1        {
 317   2        case Timer1:
 318   2        {
 319   3          return  Timer1_state == ACTIVE;
 320   3      
 321   3        };
 322   2        case Timer2:
 323   2        {
 324   3          return  Timer2_state == ACTIVE;
 325   3      
 326   3        };
 327   2        break;
 328   2        }
 329   1      }
 330          //ʱﵽ趨ʱʱ1
 331          //************************************
 332          // Method:    isExpiredTimer
 333          // FullName:  isExpiredTimer
 334          // Access:    public 
 335          // Returns:   bit
 336          // Qualifier: ʱĶʱʱѵ򷵻1
 337          // Parameter: u8 whichTimer
 338          //************************************
 339          bit isExpiredTimer(u8 whichTimer)
 340          {
 341   1        switch (whichTimer)
 342   1        {
 343   2        case Timer1:
 344   2        {
 345   3          return  Timer1_state == EXPIRED;
 346   3        };
 347   2        case Timer2:
 348   2        {
 349   3          return  Timer2_state == EXPIRED;
 350   3        };
 351   2        break;
 352   2        }
 353   1      
 354   1      
 355   1      }
 356          //ʱֹͣʱ1
 357          //************************************
 358          // Method:    isStopped
 359          // FullName:  isStopped
 360          // Access:    public 
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 7   

 361          // Returns:   bit
 362          // Qualifier: ʱѾֹͣ򷵻1
 363          // Parameter: u8 whichtimer
 364          //************************************
 365          bit isStopped(u8 whichtimer)
 366          {
 367   1        switch (whichtimer)
 368   1        {
 369   2        case Timer1:
 370   2        {
 371   3          return  Timer1_state == STOPPED;
 372   3        };
 373   2        case Timer2:
 374   2        {
 375   3          return  Timer2_state == STOPPED;
 376   3        };
 377   2        break;
 378   2        }
 379   1      }
 380          
 381          //
 382          //************************************
 383          // Method:    restartTimer
 384          // FullName:  restartTimer
 385          // Access:    public 
 386          // Returns:   void
 387          // Qualifier: ʼ򿪶ʱҪúöʱʱƵ
 388          // Parameter: u8 whichTimer
 389          //************************************
 390          void restartTimer(u8 whichTimer)
 391          {
 392   1        if (!isActiveTimer(whichTimer))
 393   1        {
 394   2          switch (whichTimer)
 395   2          {
 396   3          case Timer1:
 397   3          {
 398   4            Timer4_Run();
 399   4            Timer1_state = ACTIVE;
 400   4            //    Timer1_state = EXPIRED;
 401   4            //    PrintString1("timer 1 is expired\r\n");
 402   4      
 403   4          };
 404   3          break;
 405   3          case Timer2:
 406   3          {
 407   4            //      Timer3_Run();
 408   4            //      Timer2_state = ACTIVE;
 409   4          };
 410   3          break;
 411   3          default:
 412   3            break;
 413   3          }
 414   2      
 415   2      
 416   2      
 417   2        }
 418   1      }
 419          //
 420          //************************************
 421          // Method:    onRestartTimer
 422          // FullName:  onRestartTimer
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 8   

 423          // Access:    public 
 424          // Returns:   bit
 425          // Qualifier: ʱʱ󷵻1Զrestart¶ʱԴѭ
 426          // Parameter: u8 whichTimer
 427          //************************************
 428          bit onRestartTimer(u8 whichTimer)
 429          {
 430   1        if (isExpiredTimer(whichTimer))
 431   1        {
 432   2          restartTimer(whichTimer);
 433   2          return TRUE;
 434   2        }
 435   1        else
 436   1        {
 437   2          return FALSE;
 438   2        }
 439   1      
 440   1      }
 441          
 442          
 443          //ȡӿ΢
 444          u16 getMicros(void)
 445          {
 446   1      
 447   1        return  micros;
 448   1      }
 449          //ȡӿĺ
 450          u16 getMillis(void)
 451          {
 452   1        return millis;
 453   1      }
 454          u8 getSeconds(void)
 455          {
 456   1        return seconds;
 457   1      }
 458          u8 getMinutes(void)
 459          {
 460   1        return minutes;
 461   1      }
 462          u8 getHours(void)
 463          {
 464   1        return hours;
 465   1      }
 466          u8 getDays(void)
 467          {
 468   1        return days;
 469   1      }
 470          
 471          
 472          //========================˽кҪ˽ҲҪĶκγ򣡣=================//
 473          /********************* Timer4жϺ************************/
 474          static void timer4_int(void) interrupt TIMER4_VECTOR
 475          {
 476   1      
 477   1      
 478   1        if ((++Timer1_temp) >= timer1_struct.Timeout)
 479   1        {
 480   2      
 481   2                Timer4_Stop();
 482   2      
 483   2          Timer1_temp = 0;
 484   2          Timer1_state = EXPIRED;
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 9   

 485   2        }
 486   1      
 487   1      }
 488          
 489          /********************* Timer1жϺ************************/
 490          //static void Timer1_ISR(void) interrupt TIMER1_VECTOR
 491          //{
 492          
 493          //  if ((++Timer1_temp) >= timer1_struct.Timeout)
 494          //  {
 495          //    Timer1_Stop();
 496          //    Timer1_temp = 0;
 497          //    Timer1_state = EXPIRED;
 498          //  }
 499          
 500          
 501          
 502          //}
 503          
 504          // static void timer3_int(void) interrupt TIMER2_VECTOR
 505          //{
 506          //  if ((++Timer2_temp) >= 30)
 507          //  {
 508          //    Timer2_Stop();
 509          //    Timer2_temp = 0;
 510          //    Timer2_state = EXPIRED;
 511          //  }
 512          
 513          //}
 514          
 515          /********************* Timer4жϺ************************/
 516          //
 517          //sprintfʹòµʵֵûд
 518          //static void timer4_int(void) interrupt TIMER4_VECTOR
 519          //{
 520          
 521          
 522          //  EA = 0;
 523          //  if ((micros += 10) >= 1000)
 524          //  {
 525          //    micros = 0;
 526          //    if ((++millis) >= 1000)
 527          //    {
 528          //      millis = 0;
 529          //      if ((++seconds) >= 60)
 530          //      {
 531          //        seconds = 0;
 532          //        if ((++minutes) >= 60)
 533          //        {
 534          //          minutes = 0;
 535          //          if ((++hours) >= 24)
 536          //          {
 537          //            hours = 0;
 538          //            if ((++days) == UCHAR_MAX)
 539          //            {
 540          //              days = 0;
 541          //            }
 542          
 543          //          }
 544          //        }
 545          
 546          //      }
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 10  

 547          //    }
 548          //  }
 549          
 550          //  EA = 1;
 551          //}
 552          /********************* Timer2жϺ************************/
 553          //˶ʱڵĶʱ
 554          //void Timer2_ISR (void) interrupt TIMER2_VECTOR
 555          //{
 556          //  
 557          //}
 558          
 559          
 560          // : u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 561          // : ʱʼ.
 562          // : TIMx: ṹ,οtimer.hĶ.
 563          // : ɹ0, ղ1,󷵻2.
 564          // 汾: V1.0, 2012-10-22
 565          //========================================================================
 566          static u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 567          {
 568   1        if (TIM > Timer4) return 1; //ղ
 569   1      
 570   1        if (TIM == Timer0)
 571   1        {
 572   2          if (TIMx->TIM_Mode > TIM_16BitAutoReloadNoMask) return 2; //
 573   2          TR0 = 0;    //ֹͣ
 574   2          ET0 = 0;  //ֹж
 575   2          PT0 = 0;  //ȼж
 576   2          TMOD &= 0xf0; //ʱģʽ, 16λԶװ
 577   2          AUXR &= ~0x80;  //12Tģʽ, 
 578   2          INT_CLKO &= ~0x01;  //ʱ
 579   2          if (TIMx->TIM_Interrupt == ENABLE)    ET0 = 1;  //ж
 580   2          if (TIMx->TIM_Polity == PolityHigh)   PT0 = 1;  //ȼж
 581   2          TMOD |= TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ, 3: 16λԶװ, 
             -ж
 582   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x80; //1T
 583   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x04; //Ƶ
 584   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x01; //ʱ
 585   2      
 586   2          TH0 = (u8)(TIMx->TIM_Value >> 8);
 587   2          TL0 = (u8)TIMx->TIM_Value;
 588   2          if (TIMx->TIM_Run == ENABLE)  TR0 = 1;  //ʼ
 589   2          return  0;    //ɹ
 590   2        }
 591   1      
 592   1        if (TIM == Timer1)
 593   1        {
 594   2          TR1 = 0;    //ֹͣ
 595   2          if (TIMx->TIM_Interrupt == ENABLE)    ET1 = 1;  //ж
 596   2          else                  ET1 = 0;  //ֹж
 597   2          if (TIMx->TIM_Polity == PolityHigh)   PT1 = 1;  //ȼж
 598   2          else                  PT1 = 0;  //ȼж
 599   2          if (TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask)  return 2; //
 600   2          TMOD = (TMOD & ~0x30) | TIMx->TIM_Mode; //ģʽ,0: 16λԶװ, 1: 16λʱ/, 2: 8λԶװ
 601   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~0x40;  //12T
 602   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= 0x40; //1T
 603   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) TMOD |= 0x40; //Ƶ
 604   2          else                    TMOD &= ~0x40;  //ʱ
 605   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x02; //ʱ
 606   2          else              INT_CLKO &= ~0x02;  //ʱ
 607   2      
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 11  

 608   2          TH1 = (u8)(TIMx->TIM_Value >> 8);
 609   2          TL1 = (u8)TIMx->TIM_Value;
 610   2          if (TIMx->TIM_Run == ENABLE)  TR1 = 1;  //ʼ
 611   2          return  0;    //ɹ
 612   2        }
 613   1      
 614   1        if (TIM == Timer2)    //Timer2,̶Ϊ16λԶװ, жȼ
 615   1        {
 616   2          AUXR &= ~(1 << 4);  //ֹͣ
 617   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 2);  //ж
 618   2          else                    IE2 &= ~(1 << 2); //ֹж
 619   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 620   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_12T) AUXR &= ~(1 << 2);  //12T
 621   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    AUXR |= (1 << 2); //1T
 622   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) AUXR |= (1 << 3); //Ƶ
 623   2          else                    AUXR &= ~(1 << 3);  //ʱ
 624   2          if (TIMx->TIM_ClkOut == ENABLE) INT_CLKO |= 0x04; //ʱ
 625   2          else              INT_CLKO &= ~0x04;  //ʱ
 626   2      
 627   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 628   2          TL2 = (u8)TIMx->TIM_Value;
 629   2          if (TIMx->TIM_Run == ENABLE)  AUXR |= (1 << 4); //ʼ
 630   2          return  0;    //ɹ
 631   2        }
 632   1      
 633   1        if (TIM == Timer3)    //Timer3,̶Ϊ16λԶװ, жȼ
 634   1        {
 635   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 636   2          T4T3M &= 0xf0;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 637   2          IE2 &= ~(1 << 5); //ֹж
 638   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 5);  //ж
 639   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 1);  //1T
 640   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 1);  //Ƶ
 641   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= 1; //ʱ
 642   2      
 643   2          TH3 = (u8)(TIMx->TIM_Value >> 8);
 644   2          TL3 = (u8)TIMx->TIM_Value;
 645   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 3);  //ʼ
 646   2          return  0;    //ɹ
 647   2        }
 648   1      
 649   1        if (TIM == Timer4)    //Timer4,̶Ϊ16λԶװ, жȼ
 650   1        {
 651   2          if (TIMx->TIM_ClkSource > TIM_CLOCK_Ext)  return 2;
 652   2          T4T3M &= 0x0f;    //ֹͣ, ʱģʽ, 12Tģʽ, ʱ
 653   2          IE2 &= ~(1 << 6); //ֹж
 654   2          if (TIMx->TIM_Interrupt == ENABLE)      IE2 |= (1 << 6);  //ж
 655   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_1T)    T4T3M |= (1 << 5);  //1T
 656   2          if (TIMx->TIM_ClkSource == TIM_CLOCK_Ext) T4T3M |= (3 << 5);  //Ƶ
 657   2      
 658   2          TH4 = (u8)(TIMx->TIM_Value >> 8);
 659   2          TL4 = (u8)TIMx->TIM_Value;
 660   2          if (TIMx->TIM_Run == ENABLE)  T4T3M |= (1 << 7);  //ʼ
 661   2          if (TIMx->TIM_ClkOut == ENABLE) T4T3M |= (1 << 4);  //ʱ
 662   2      
 663   2          return  0;    //ɹ
 664   2        }
 665   1      
 666   1        return 2; //
 667   1      }
 668          
 669          
C51 COMPILER V8.05a   TIMER                                                                08/01/2017 18:09:01 PAGE 12  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1065    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
