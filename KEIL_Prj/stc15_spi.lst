C51 COMPILER V8.05a   STC15_SPI                                                            06/28/2017 22:06:39 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE STC15_SPI
OBJECT MODULE PLACED IN .\stc15_spi.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\BSP\stc15_spi.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\stc1
                    -5_spi.lst) TABS(2) OBJECT(.\stc15_spi.obj)

line level    source

   1          /************************************************************
   2          * ×éÖ¯Ãû³Æ£º (C), 1988-1999, Tech. Co., Ltd.
   3          * ÎÄ¼þÃû³Æ: test.cpp
   4          * ×÷Õß:
   5          * °æ±¾ :
   6          * ÈÕÆÚ:
   7          * ÃèÊö: // Ä£¿éÃèÊö
   8          * Ö÷Òªº¯Êý¼°Æä¹¦ÄÜ : // Ö÷Òªº¯Êý¼°Æä¹¦ÄÜ
   9            1. -------
  10          * ÀúÊ·ÐÞ¸Ä¼ÇÂ¼: // ÀúÊ·ÐÞ¸Ä¼ÇÂ¼
  11          * <×÷Õß> <Ê±¼ä> <°æ±¾ > <ÃèÊö>
  12          * David 96/10/12 1.0 build this moudle
  13          ***********************************************************/
  14          //------------------------------------------------
  15          //Í·ÎÄ¼þ
  16          #include "stc15_spi.h"
  17          //------------------------------------------------------------------------
  18          //×¢Òâ:
  19          //ÒÔÏÂ¿âº¯Êý¶¼ÊÇ½¨Á¢ÔÚ
  20          //SPI_SSIG=DISABLE-->SPCTLµÄÎ»4 MSTR À´È·¶¨Ö÷»ú»¹ÊÇ´Ó»ú
  21          //SPI_Mode=SPI_Mode_MasterÖ÷»ú
  22          //µÄÇé¿öÏÂµÄ
  23          //Ò»°ãÓÃmcuµÄSPI ¾ÍÊÇÖ÷»úÄ£Ê½ Õâ¸öÄ£Ê½×î³£ÓÃ
  24          //ËäÈ»³õÊ¼»¯µÄÊ±ºòÎÒ¿ÉÒÔÉèÖÃ³ÉÆäËüÄ£Ê½,µ«ÎÒµÄ¿âº¯ÊýÖ»Ö§³ÖÉÏÃæÎÒËµµÄÉèÖÃ
  25          //------------------------------------------------
  26          //Ô¤¶¨Òå
  27          #define SPI_BUF_LENTH   32
  28          #define SPI_BUF_type    idata
  29          //------------------------------------------------
  30          //¾²Ì¬±äÁ¿
  31          static u8   SPI_TxWrite;
  32          static u8   SPI_TxRead;
  33          static u8   SPI_BUF_type SPI_TxBuffer[SPI_BUF_LENTH];
  34          static u8   SPI_RxWrite;
  35          static u8   SPI_RxRead;
  36          static u8   SPI_BUF_type SPI_RxBuffer[SPI_BUF_LENTH];
  37          //------------------------------------------------------------------------
  38          //È«¾Öº¯Êý
  39          //void  SPI_Init                        (SPI_InitTypeDef *SPIx);    //SPI³õÊ¼»¯³ÌÐò.
  40          //void  SPI_SetMode                     (u8 mode);                  //SPIÉèÖÃÖ÷´ÓÄ£Ê½º¯Êý.
  41          //void  SPI_WriteByteToTxBuf            (u8 dat);                   //SPI×°ÔØÒª·¢ËÍµÄ1¸ö×Ö½Ú µ«ÏÈ²»·¢ËÍ
  42          //void  SPI_WriteNByteToTxBuf           (u8 *sp,u8 num);            //SPI×°ÔØÒª·¢ËÍµÄN¸ö×Ö½Ú µ«ÏÈ²»·¢ËÍ
  43          //void  SPI_TrigTx                      (void);                     //´¥·¢SPI·¢ËÍº¯Êý, ½«·¢ËÍ»º³åµÄÊý¾Ý·¢³
             -ö
  44          //u8    SPI_SPI_ReadByteToRxBuf         (void);                     //SPI´Ó¶Á»º³åÇøÀï¶Á³ö1¸ö×Ö½Ú
  45          //u8    SPI_SPI_ReadTheNByteToRxBuf     (u8 num);                   //SPI´Ó¶Á»º³åÇøÀï¶Á³öµÚN¸ö×Ö½Ú Ö®Ç°µÄN
             --1¸ö×Ö½Ú¶¼¶ªÆú
  46          ///////////////////////////////////////////////////////////////
  47          //È«¾Öº¯Êý
  48          /////////////////////////////////////////////////////////////////////
  49          // º¯Êý: void   SPI_Init(SPI_InitTypeDef *SPIx)
  50          // ÃèÊö: SPI³õÊ¼»¯³ÌÐò.
  51          // ²ÎÊý: SPIx: ½á¹¹²ÎÊý,Çë²Î¿¼spi.hÀïµÄ¶¨Òå.
  52          void    SPI_Init(SPI_InitTypeDef *SPIx)
C51 COMPILER V8.05a   STC15_SPI                                                            06/28/2017 22:06:39 PAGE 2   

  53          {
  54   1          if(SPIx->SPI_SSIG == ENABLE)
  55   1          {
  56   2              SPCTL &= ~(1<<7);    //enable SS, conform Master or Slave by SS pin. Ä¿Ç°Ö»Ö§³ÖDISABLE
  57   2          }
  58   1          else
  59   1          {
  60   2              SPCTL |=  (1<<7);    //disable SS, conform Master or Slave by SPI_Mode
  61   2          }
  62   1          if(SPIx->SPI_Module == ENABLE)
  63   1          {
  64   2              SPCTL |=  (1<<6);    //SPI enable
  65   2          }
  66   1          else
  67   1          {
  68   2              SPCTL &= ~(1<<6);    //SPI disable
  69   2          }
  70   1          if(SPIx->SPI_FirstBit == SPI_LSB)
  71   1          {
  72   2              SPCTL |=  (1<<5);    //LSB first
  73   2          }
  74   1          else
  75   1          {
  76   2              SPCTL &= ~(1<<5);    //MSB first
  77   2          }
  78   1          if(SPIx->SPI_Mode == SPI_Mode_Slave)
  79   1          {
  80   2              SPCTL &= ~(1<<4);    //slave  Ä¿Ç°Ö»Ö§³ÖSPI_Mode_Master
  81   2          }
  82   1          else
  83   1          {
  84   2              SPCTL |=  (1<<4);    //master
  85   2          }
  86   1          if(SPIx->SPI_CPOL == SPI_CPOL_High)
  87   1          {
  88   2              SPCTL |=  (1<<3);    //SCLK Idle High, Low Active.
  89   2          }
  90   1          else
  91   1          {
  92   2              SPCTL &= ~(1<<3);    //SCLK Idle Low, High Active.
  93   2          }
  94   1          if(SPIx->SPI_CPHA == SPI_CPHA_2Edge)
  95   1          {
  96   2              SPCTL |=  (1<<2);    //sample at the second edge
  97   2          }
  98   1          else
  99   1          {
 100   2              SPCTL &= ~(1<<2);    //sample at the first  edge
 101   2          }
 102   1          if(SPIx->SPI_Interrupt == ENABLE)
 103   1          {
 104   2              IE2 |=  (1<<1);    //Ä¿Ç°Ö»Ö§³ÖENABLE
 105   2          }
 106   1          else
 107   1          {
 108   2              IE2 &= ~(1<<1);
 109   2          }
 110   1          SPCTL = (SPCTL & ~3) | (SPIx->SPI_Speed & 3);                   //set speed
 111   1          AUXR1 = (AUXR1 & ~(3<<2)) | SPIx->SPI_IoUse;
 112   1      }
 113          ///////////////////////////////////////////////////////////////////////
 114          // º¯Êý: void   SPI_SetMode(u8 mode)
C51 COMPILER V8.05a   STC15_SPI                                                            06/28/2017 22:06:39 PAGE 3   

 115          // ÃèÊö: SPIÉèÖÃÖ÷´ÓÄ£Ê½º¯Êý.
 116          // ²ÎÊý: mode: Ö¸¶¨Ä£Ê½,È¡Öµ SPI_Mode_Master »ò SPI_Mode_Slave
 117          // ×¢Òâ: Ä¿Ç°Ö»Ö§³ÖSPI_Mode_Master
 118          void    SPI_SetMode(u8 mode)
 119          {
 120   1          if(mode == SPI_Mode_Slave)
 121   1          {
 122   2              SPCTL &= ~(1<<4);   //slave
 123   2          }
 124   1          else
 125   1          {
 126   2              SPCTL |=  (1<<4);   //master
 127   2          }
 128   1      }
 129          //////////////////////////////////////////////////////////////
 130          // º¯Êý: void SPI_WriteByteToTxBuf(u8 dat)
 131          // ÃèÊö: SPI×°ÔØ·¢Òª·¢ËÍµÄ1¸ö×Ö½Ú µ«ÏÈ²»·¢ËÍ
 132          // ²ÎÊý: dat: Òª·¢ËÍµÄÖµ
 133          void SPI_WriteByteToTxBuf(u8 dat)   //Ð´Èë·¢ËÍ»º³å£¬Ö¸Õë+1
 134          {
 135   1          SPI_TxBuffer[SPI_TxWrite] = dat;
 136   1          if(++SPI_TxWrite >= SPI_BUF_LENTH)
 137   1          {
 138   2              SPI_TxWrite = 0;
 139   2          }
 140   1      }
 141          //////////////////////////////////////////////////////////////
 142          // º¯Êý: void SPI_WriteNByteToTxBuf(u8 *sp,u8 num)
 143          // ÃèÊö: SPI×°ÔØÒª·¢ËÍµÄN¸ö×Ö½Ú µ«ÏÈ²»·¢ËÍ
 144          // ²ÎÊý: *sp: Ö¸ÏòÒª·¢ËÍµÄN¸ö×Ö½ÚµÄÊ×µØÖ·
 145          //       num: Òª×°ÔØ×Ö½ÚµÄÊýÁ¿  ²»Òª³¬¹ýSPI_BUF_LENTH
 146          // ×¢Òâ: SPI_BUF_LENTH³¤¶ÈÎÊÌâ
 147          void    SPI_WriteNByteToTxBuf(u8 *sp,u8 num)
 148          {
 149   1          u8 i=num;
 150   1          u8 *spp=sp;
 151   1          if(num>SPI_BUF_LENTH)
 152   1          {
 153   2              ;
 154   2          }
 155   1          else
 156   1          {
 157   2              for(i=0; i<num; i++)
 158   2              {
 159   3                  SPI_WriteByteToTxBuf(*spp);
 160   3                  spp++;
 161   3              }
 162   2          }
 163   1      }
 164          //////////////////////////////////////////////////////////////////////////////
 165          // º¯Êý: void   SPI_TrigTx(void)
 166          // ÃèÊö: ´¥·¢SPI·¢ËÍº¯Êý, ½«·¢ËÍ»º³åµÄÊý¾Ý·¢³ö
 167          void SPI_TrigTx(void)
 168          {
 169   1          u8  i;
 170   1          if(SPI_TxRead == SPI_TxWrite)
 171   1          {
 172   2              ;
 173   2          }
 174   1          else
 175   1          {
 176   2              SPI_SetMode(SPI_Mode_Master);
C51 COMPILER V8.05a   STC15_SPI                                                            06/28/2017 22:06:39 PAGE 4   

 177   2              i = SPI_TxBuffer[SPI_TxRead];
 178   2              if(++SPI_TxRead >= SPI_BUF_LENTH)
 179   2              {
 180   3                  SPI_TxRead = 0;
 181   3              }
 182   2              SPDAT = i;
 183   2          }
 184   1      }
 185          //////////////////////////////////////////////////////////////
 186          // º¯Êý: u8 SPI_SPI_ReadByteToRxBuf(void)
 187          // ÃèÊö: SPI´Ó¶Á»º³åÇøÀï¶Á³ö1¸ö×Ö½Ú
 188          // ·µ»Ø²ÎÊý:¶Á³öÕâ¸ö×Ö½ÚµÄÖµ
 189          // ×¢Òâ: ³ÌÐòÔ±Òª±£Ö¤»º³åÇøÀïÈ·ÊµÖÁÉÙÓÐ1¸ö»¹Ã»ÓÐ¶Á³öµÄÊý¾Ý
 190          u8 SPI_SPI_ReadByteToRxBuf(void)
 191          {
 192   1          u8 dat;
 193   1          if(SPI_RxRead==SPI_RxWrite)
 194   1          {
 195   2              return 0;//·µ»ØµÄ0 ²»ÊÇ¶Á³öµÄÖµ ¶øÊÇ»º³åÇøÀïÃ»ÓÐÒª¶Á³öµÄÊý¾Ý
 196   2          }
 197   1          else
 198   1          {
 199   2              dat=SPI_RxBuffer[SPI_RxRead];
 200   2              if(++SPI_RxRead >= SPI_BUF_LENTH)
 201   2              {
 202   3                  SPI_RxRead = 0;
 203   3              }
 204   2          }
 205   1          return dat;
 206   1      }
 207          //////////////////////////////////////////////////////////////
 208          // º¯Êý: u8 SPI_SPI_ReadByteToRxBuf(void)
 209          // ÃèÊö: SPI´Ó¶Á»º³åÇøÀï¶Á³öµÚN¸ö×Ö½Ú Ö®Ç°µÄN-1¸ö×Ö½Ú¶¼¶ªÆú
 210          // ·µ»Ø²ÎÊý:¶Á³öÕâ¸ö×Ö½ÚµÄÖµ
 211          // ×¢Òâ: ³ÌÐòÔ±Òª±£Ö¤»º³åÇøÀïÈ·ÊµÖÁÉÙÓÐN¸ö»¹Ã»ÓÐ¶Á³öµÄÊý¾Ý
 212          // ×¢Òâ: SPI_BUF_LENTH³¤¶ÈÎÊÌâ
 213          u8 SPI_SPI_ReadTheNByteToRxBuf(u8 num)
 214          {
 215   1          u8 i=num;
 216   1          u8 dat;
 217   1          if(i>SPI_BUF_LENTH)
 218   1          {
 219   2              return 0;//·µ»ØµÄ0 ²»ÊÇ¶Á³öµÄÖµ ¶øÊÇÐÎÊ½²ÎÊý²»ºÏ·¨
 220   2          }
 221   1          else
 222   1          {
 223   2              while(i>1)
 224   2              {
 225   3                  SPI_SPI_ReadByteToRxBuf();
 226   3                  i--;
 227   3              }
 228   2              dat=SPI_SPI_ReadByteToRxBuf();
 229   2              return dat;
 230   2          }
 231   1      }
 232          ////////////////////////////////////////////////////////////////////
 233          // º¯Êý: void SPI_Transivion (void) interrupt SPI_VECTOR
 234          // ÃèÊö: SPIÖÐ¶Ïº¯Êý.
 235          void SPI_Transivion (void) interrupt SPI_VECTOR
 236          {
 237   1          if(SPI_TxRead != SPI_TxWrite)
 238   1          {
C51 COMPILER V8.05a   STC15_SPI                                                            06/28/2017 22:06:39 PAGE 5   

 239   2              //ÔÚÐ´Êý¾ÝÖ®Ç°ÏÈ¶Á³öSPDAT
 240   2              SPI_RxBuffer[SPI_RxWrite] = SPDAT ;
 241   2              if(++SPI_RxWrite >= SPI_BUF_LENTH)
 242   2              {
 243   3                  SPI_RxWrite = 0;
 244   3              }
 245   2              SPDAT = SPI_TxBuffer[SPI_TxRead];
 246   2              if(++SPI_TxRead >= SPI_BUF_LENTH)
 247   2              {
 248   3                  SPI_TxRead = 0;
 249   3              }
 250   2          }
 251   1          SPSTAT = SPIF + WCOL;   //Çå0 SPIFºÍWCOL±êÖ¾
 252   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    394    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =     64    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
