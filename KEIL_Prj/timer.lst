C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\BSP\timer.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\timer.ls
                    -t) TABS(2) OBJECT(.\timer.obj)

line level    source

   1          /************************************************************
   2          * ÎÄ¼þÃû³Æ: timer.c
   3          * ×÷Õß: ÖÜ³¿Ñô
   4          * °æ±¾: 1.0
   5          * ÈÕÆÚ: 2017/4/29
   6          * ÃèÊö: // 
   7          * Ö÷Òªº¯Êý¼°Æä¹¦ÄÜ : ¶¨Ê±Æ÷µÄÊ¹ÓÃ£¬ÓÐTimer1£¬ºÍTimer2¿É¹©¶ÀÁ¢Ê¹ÓÃ
   8          * ÀúÊ·ÐÞ¸Ä¼ÇÂ¼: // ÀúÊ·ÐÞ¸Ä¼ÇÂ¼
   9          * <×÷Õß> <Ê±¼ä> <°æ±¾ > <ÃèÊö>
  10          * ÖÜ³¿Ñô 2017/4/29 Ìí¼ÓÁË´ËÎÄ¼þËµÃ÷×¢ÊÍ
  11          ***********************************************************/
  12          //////////////////////¶¨Ê±Æ÷µäÐÍÓ¦ÓÃ/////////////////////////////////////// 
  13          /*
  14                  
  15                  
  16                  setTimeout(Timer1,5000); //ÉèÖÃ¶¨Ê±Æ÷¶¨Ê±³¤¶È ,5Ãë
  17                  while(1)
  18                  {
  19                    if(isExpiredTimer(Timer1))   //Èç¹û´ïµ½¶¨Ê±Ê±¼ä
  20                    {
  21                       stopTimer(Timer1);//´ïµ½¶¨Ê±Ê±¼äºóÒ»¶¨Òª¹Ø±Õ¶¨Ê±Æ÷£¬·ñÔò»áÎÞ·¨ÖØ¸´Ê¹ÓÃ¶¨Ê±Æ÷
  22                      //¶¨Ê±Ê±¼äµ½£¬ÄãµÄ´úÂëÐ´ÔÚÕâ
  23                    }
  24                    else//Èç¹ûÎ´´ïµ½¶¨Ê±Ê±¼ä»ò¶¨Ê±Æ÷Î´Æô¶¯
  25                    { 
  26                      
  27                    
  28                        restartTimer(Timer1);
  29                        
  30                      
  31                    }
  32                  }
  33          */ 
  34          ///////////////////////////////////////////////////////////////    
  35          #include  "timer.h"
  36           enum 
  37          {
  38             ACTIVE,EXPIRED,STOPPED
  39          } 
  40            Timer1_state=STOPPED,
  41            Timer2_state=STOPPED;
  42           static u16 Timer1_temp=0;
  43           static u16 Timer2_temp=0;
  44          
  45          struct TimerInfo
  46          {
  47             u16 Timeout;
  48            u16 Hz;
  49          }
  50          timer1_struct={0,0},
  51          timer2_struct={0,0};
  52           
  53          
  54          void timerInit()
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 2   

  55          {
  56   1        TIM_InitTypeDef   TIM_InitStructure1; //ÓÃ»§×Ô¶¨Òå¶¨Ê±Æ÷Ê¹ÓÃ
  57   1        TIM_InitTypeDef   TIM_InitStructure2; //¾ø¶ÔÊ±¼ä»ñÈ¡Ê¹ÓÃ
  58   1      
  59   1        TIM_InitStructure1.TIM_Mode      = TIM_16BitAutoReload; //Ö¸¶¨¹¤×÷Ä£Ê½,16Î»×Ô¶¯ÖØ×°Ä£Ê½    TIM_16BitAutoR
             -eload,TIM_16Bit,TIM_8BitAutoReload,\\
*** WARNING C329 IN LINE 59 OF ..\HARDWARE\BSP\timer.c: single-line comment contains line-continuation
  60   1                                                                                                                        TIM_16BitAutoReloadNoMask
  61   1        TIM_InitStructure1.TIM_Polity    = PolityLow;     //Ö¸¶¨ÖÐ¶ÏÓÅÏÈ¼¶, PolityHigh,PolityLow
  62   1        TIM_InitStructure1.TIM_Interrupt = ENABLE;        //ÖÐ¶ÏÊÇ·ñÔÊÐí,   ENABLE»òDISABLE
  63   1        TIM_InitStructure1.TIM_ClkSource = TIM_CLOCK_1T;  //Ö¸¶¨Ê±ÖÓÔ´,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_E
             -xt
  64   1        TIM_InitStructure1.TIM_ClkOut    = DISABLE;       //ÊÇ·ñÊä³ö¸ßËÙÂö³å, ENABLE»òDISABLE
  65   1        TIM_InitStructure1.TIM_Run       = DISABLE;       //ÊÇ·ñ³õÊ¼»¯ºóÆô¶¯¶¨Ê±Æ÷, ENABLE»òDISABLE
  66   1        TIM_InitStructure1.TIM_Value     = 65536UL - (MAIN_Fosc / 1000);    //³õÖµ,1000us
  67   1       
  68   1        TIM_InitStructure2.TIM_Mode      = TIM_16BitAutoReload; //Ö¸¶¨¹¤×÷Ä£Ê½,16Î»×Ô¶¯ÖØ×°Ä£Ê½   TIM_16BitAutoR
             -eload,TIM_16Bit,TIM_8BitAutoReload,\\
*** WARNING C329 IN LINE 68 OF ..\HARDWARE\BSP\timer.c: single-line comment contains line-continuation
  69   1                                                                                                                        TIM_16BitAutoReloadNoMask
  70   1        TIM_InitStructure2.TIM_Polity    = PolityLow;     //Ö¸¶¨ÖÐ¶ÏÓÅÏÈ¼¶, PolityHigh,PolityLow
  71   1        TIM_InitStructure2.TIM_Interrupt = ENABLE;        //ÖÐ¶ÏÊÇ·ñÔÊÐí,   ENABLE»òDISABLE
  72   1        TIM_InitStructure2.TIM_ClkSource = TIM_CLOCK_1T;  //Ö¸¶¨Ê±ÖÓÔ´,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_E
             -xt
  73   1        TIM_InitStructure2.TIM_ClkOut    = DISABLE;       //ÊÇ·ñÊä³ö¸ßËÙÂö³å, ENABLE»òDISABLE
  74   1        TIM_InitStructure2.TIM_Run       = ENABLE;        //ÊÇ·ñ³õÊ¼»¯ºóÆô¶¯¶¨Ê±Æ÷, ENABLE»òDISABLE
  75   1        TIM_InitStructure2.TIM_Value     = 65536UL - (MAIN_Fosc / 4);   //³õÖµ,4us
  76   1      
  77   1        Timer_Inilize(Timer1,&TIM_InitStructure1);  //ÓÃ»§×Ô¶¨Òå¶¨Ê±Æ÷    
  78   1        Timer_Inilize(Timer3,&TIM_InitStructure1);  //ÓÃ»§×Ô¶¨Òå¶¨Ê±Æ÷  
  79   1        Timer_Inilize(Timer4,&TIM_InitStructure2);  //¾ø¶ÔÊ±¼ä»ñÈ¡Ê¹ÓÃ
  80   1        
  81   1      }
  82          static unsigned long microsTemp=0;//¾ø¶ÔÊ±¼ä»ñÈ¡±äÁ¿
  83          static unsigned long millisTemp=0;//¾ø¶ÔÊ±¼ä»ñÈ¡±äÁ¿
  84          //»ñÈ¡´Ó¿ª»úºóµÄÎ¢ÃëÊý
  85          unsigned long getMicros()
  86          {
  87   1      
  88   1         return  microsTemp;
  89   1      }
  90          //»ñÈ¡´Ó¿ª»úºóµÄºÁÃëÊý
  91          unsigned long getMillis()
  92          {
  93   1         return millisTemp;
  94   1      }
  95          //ÉèÖÃ¶¨Ê±Æ÷µÄ·¢ÉúÆµÂÊ
  96          void setTimerHertz(u8 whichTimer,u16 Hz)
  97          {            
  98   1           switch(whichTimer)
  99   1           {
 100   2            
 101   2             case Timer1:
 102   2             {
 103   3              timer1_struct.Hz=Hz;  
 104   3             };
 105   2             break;
 106   2             case Timer2:
 107   2             {
 108   3              timer2_struct.Hz=Hz;  
 109   3             };
 110   2             break;
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 3   

 111   2             
 112   2           }
 113   1      
 114   1        
 115   1      }
 116          u16 getTimerHertz(u8 whichTimer)
 117          {
 118   1         switch(whichTimer)
 119   1         {
 120   2          
 121   2           break;
 122   2           case Timer1:
 123   2           {
 124   3              return timer1_struct.Hz;
 125   3           };
 126   2           break;
 127   2           case Timer2:
 128   2           {
 129   3              return timer2_struct.Hz;
 130   3           };
 131   2           break;
 132   2          default: return 0;
 133   2         }
 134   1      }
 135          //ÉèÖÃ¶¨Ê±Æ÷µÄ¶¨Ê±Ê±¼ä
 136          void setTimeout(u8 whichTimer,u16 time)
 137          {
 138   1      if(!(Timer1_state==ACTIVE||Timer2_state==ACTIVE)) 
 139   1      { 
 140   2        switch(whichTimer)
 141   2        {
 142   3      
 143   3          case Timer1:
 144   3          {
 145   4            timer1_struct.Timeout=time;         
 146   4          };
 147   3          case Timer2:
 148   3          {
 149   4            timer2_struct.Timeout=time;         
 150   4          };    
 151   3          default:
 152   3            break;  
 153   3        }
 154   2      }
 155   1      }
 156          u16 getTimerout(u8 whichTimer)
 157          {
 158   1         switch(whichTimer)
 159   1         {
 160   2          
 161   2           case Timer1:
 162   2           {
 163   3              return timer1_struct.Timeout;
 164   3           };
 165   2           break;
 166   2           case Timer2:
 167   2           {
 168   3              return timer2_struct.Timeout;
 169   3           };
 170   2           break;
 171   2          
 172   2          default: return 0;
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 4   

 173   2         }
 174   1        
 175   1      }
 176          //Í£ÓÃ¶¨Ê±Æ÷
 177          void stopTimer(u8 whichTimer)
 178          {   switch(whichTimer)
 179   1        { 
 180   2          case Timer1:
 181   2          {
 182   3            Timer1_Stop();
 183   3           Timer1_state= STOPPED;
 184   3      
 185   3          };
 186   2          break;
 187   2          case Timer2:
 188   2          {
 189   3            Timer3_Stop();//´Ë´¦¾ÍÊÇtimer3£¬²»ÊÇtimer2£¬timer2Ìø¹ýÁË£¬ÒòÎªÁô¸ø´®¿ÚÊ¹ÓÃÁË    
 190   3           Timer2_state= STOPPED;
 191   3      
 192   3          };
 193   2          break;
 194   2        }
 195   1         
 196   1      }
 197          //Èô¶¨Ê±Æ÷ÒÑÆô¶¯µ«Î´´ïµ½¶¨Ê±Ê±¼ä·µ»Ø1
 198          bit isActiveTimer(u8 whichTimer)
 199          {
 200   1         switch(whichTimer)
 201   1         {
 202   2           case Timer1 :
 203   2           {
 204   3           return  Timer1_state == ACTIVE;
 205   3      
 206   3           };
 207   2           case Timer2 :
 208   2           {
 209   3           return  Timer2_state == ACTIVE;
 210   3      
 211   3           };
 212   2           break;
 213   2         }
 214   1      }
 215          //µ±¶¨Ê±´ïµ½Éè¶¨Ê±¼äÊ±·µ»Ø1
 216          bit isExpiredTimer(u8 whichTimer)
 217          {
 218   1           switch(whichTimer)
 219   1        {
 220   2          case Timer1:
 221   2          {
 222   3              return  Timer1_state == EXPIRED;
 223   3          };
 224   2          case Timer2:
 225   2          {
 226   3              return  Timer2_state == EXPIRED;
 227   3          };
 228   2          break;
 229   2        }
 230   1            
 231   1         
 232   1      }
 233          //µ±¶¨Ê±Æ÷±»Í£Ö¹Ê±·µ»Ø1
 234          bit isStopped(u8 whichtimer)
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 5   

 235          {
 236   1         switch(whichtimer)
 237   1        {
 238   2          case Timer1:
 239   2          {
 240   3              return  Timer1_state == STOPPED;
 241   3          };
 242   2          case Timer2:
 243   2          {
 244   3              return  Timer2_state == STOPPED;
 245   3          };
 246   2          break;
 247   2        }
 248   1      }
 249          
 250          //³õÊ¼»¯²¢´ò¿ª¶¨Ê±Æ÷£¬ÐèÒªÏÈÉèÖÃºÃ¶¨Ê±Ê±¼ä»òÆµÂÊ
 251          void restartTimer(u8 whichTimer)
 252          {
 253   1          if(!isStopped(whichTimer))
 254   1          {
 255   2             switch(whichTimer)
 256   2            {
 257   3              case Timer1:
 258   3              {
 259   4                Timer1_Run();
 260   4                Timer1_state= ACTIVE;
 261   4              };
 262   3              break;
 263   3              case Timer2:
 264   3              {
 265   4                Timer3_Run();
 266   4                Timer2_state= ACTIVE;
 267   4              };
 268   3              break;
 269   3              default:
 270   3                break;
 271   3            }
 272   2             
 273   2            
 274   2         
 275   2          }
 276   1      }
 277          //µ±¶¨Ê±Æ÷¶¨Ê±½áÊøºó·µ»Ø1£¬²¢×Ô¶¯µ÷ÓÃrestart£¨£©£¬ÖØÐÂ¶¨Ê±
 278          bit onRestartTimer(u8 whichTimer)
 279          {
 280   1          if (isExpiredTimer(whichTimer))
 281   1          {
 282   2            restartTimer(whichTimer);
 283   2            return TRUE;
 284   2          }
 285   1          else
 286   1          {
 287   2            return FALSE;
 288   2          } 
 289   1        
 290   1      }
 291          
 292          
 293          /********************* Timer1ÖÐ¶Ïº¯Êý************************/
 294          void Timer1_ISR (void) interrupt TIMER1_VECTOR
 295          {
 296   1      
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 6   

 297   1         if(++Timer1_temp==timer1_struct.Timeout)
 298   1           {
 299   2              Timer1_Stop();
 300   2              Timer1_temp=0;
 301   2              Timer1_state= EXPIRED;
 302   2           }
 303   1           
 304   1           
 305   1      
 306   1      }
 307          
 308          
 309          /********************* Timer3ÖÐ¶Ïº¯Êý************************/
 310          void timer3_int (void) interrupt TIMER3_VECTOR
 311          {
 312   1          if(++Timer2_temp==timer2_struct.Timeout)
 313   1           {
 314   2              Timer3_Stop();
 315   2              Timer2_temp=0;
 316   2              Timer2_state= EXPIRED;
 317   2           }
 318   1           
 319   1      }
 320          
 321          /********************* Timer4ÖÐ¶Ïº¯Êý************************/
 322          void timer4_int (void) interrupt TIMER4_VECTOR
 323          {   
 324   1          if(millisTemp=microsTemp/1000>=4294967290ul)millisTemp=0;;
 325   1          if((microsTemp+=4)>=4294967290ul) microsTemp=0;
 326   1      }
 327          /********************* Timer2ÖÐ¶Ïº¯Êý************************/
 328          //´Ë¶¨Ê±Æ÷ÓÃ×÷´®¿ÚµÄ¶¨Ê±Æ÷ÁË
 329          //void Timer2_ISR (void) interrupt TIMER2_VECTOR
 330          //{
 331          //  
 332          //}
 333          
 334          
 335          //========================£¡£¡£¡²»Òª¸Ä¶¯ÒÔÏÂÈÎºÎ³ÌÐò£¡£¡£¡=================
 336          // º¯Êý: u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 337          // ÃèÊö: ¶¨Ê±Æ÷³õÊ¼»¯³ÌÐò.
 338          // ²ÎÊý: TIMx: ½á¹¹²ÎÊý,Çë²Î¿¼timer.hÀïµÄ¶¨Òå.
 339          // ·µ»Ø: ³É¹¦·µ»Ø0, ¿Õ²Ù×÷·µ»Ø1,´íÎó·µ»Ø2.
 340          // °æ±¾: V1.0, 2012-10-22
 341          //========================================================================
 342          static u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 343          {
 344   1        if(TIM > Timer4)  return 1; //¿Õ²Ù×÷
 345   1      
 346   1        if(TIM == Timer0)
 347   1        {
 348   2          if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 349   2          TR0 = 0;    //Í£Ö¹¼ÆÊý
 350   2          ET0 = 0;  //½ûÖ¹ÖÐ¶Ï
 351   2          PT0 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 352   2          TMOD &= 0xf0; //¶¨Ê±Ä£Ê½, 16Î»×Ô¶¯ÖØ×°
 353   2          AUXR &= ~0x80;  //12TÄ£Ê½, 
 354   2          INT_CLKO &= ~0x01;  //²»Êä³öÊ±ÖÓ
 355   2          if(TIMx->TIM_Interrupt == ENABLE)   ET0 = 1;  //ÔÊÐíÖÐ¶Ï
 356   2          if(TIMx->TIM_Polity == PolityHigh)    PT0 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 357   2          TMOD |= TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3: 16Î»×Ô¶¯ÖØ×°, ²
             -»¿ÉÆÁ±ÎÖÐ¶Ï
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 7   

 358   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x80;  //1T
 359   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x04;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 360   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;  //Êä³öÊ±ÖÓ
 361   2          
 362   2          TH0 = (u8)(TIMx->TIM_Value >> 8);
 363   2          TL0 = (u8)TIMx->TIM_Value;
 364   2          if(TIMx->TIM_Run == ENABLE) TR0 = 1;  //¿ªÊ¼ÔËÐÐ
 365   2          return  0;    //³É¹¦
 366   2        }
 367   1      
 368   1        if(TIM == Timer1)
 369   1        {
 370   2          if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 371   2          TR1 = 0;  //Í£Ö¹¼ÆÊý
 372   2          ET1 = 0;  //½ûÖ¹ÖÐ¶Ï
 373   2          PT1 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 374   2          TMOD &=  0x0f;  //¶¨Ê±Ä£Ê½, 16Î»×Ô¶¯ÖØ×°
 375   2          AUXR &= ~0x40;  //12TÄ£Ê½, 
 376   2          INT_CLKO &= ~0x02;  //²»Êä³öÊ±ÖÓ
 377   2          if(TIMx->TIM_Interrupt == ENABLE)   ET1 = 1;  //ÔÊÐíÖÐ¶Ï
 378   2          if(TIMx->TIM_Polity == PolityHigh)    PT1 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 379   2          TMOD |= (TIMx->TIM_Mode << 4);  //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°
 380   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x40;  //1T
 381   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x40;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 382   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;  //Êä³öÊ±ÖÓ
 383   2          
 384   2          TH1 = (u8)(TIMx->TIM_Value >> 8);
 385   2          TL1 = (u8)TIMx->TIM_Value;
 386   2          if(TIMx->TIM_Run == ENABLE) TR1 = 1;  //¿ªÊ¼ÔËÐÐ
 387   2          return  0;    //³É¹¦
 388   2        }
 389   1      
 390   1        if(TIM == Timer2)   //Timer2,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 391   1        {
 392   2          if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
 393   2          AUXR &= ~0x1c;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½
 394   2          IE2  &= ~(1<<2);  //½ûÖ¹ÖÐ¶Ï
 395   2          INT_CLKO &= ~0x04;  //²»Êä³öÊ±ÖÓ
 396   2          if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<2);  //ÔÊÐíÖÐ¶Ï
 397   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  (1<<2);  //1T
 398   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  AUXR |=  (1<<3);  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 399   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;  //Êä³öÊ±ÖÓ
 400   2      
 401   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 402   2          TL2 = (u8)TIMx->TIM_Value;
 403   2          if(TIMx->TIM_Run == ENABLE) AUXR |=  (1<<4);  //¿ªÊ¼ÔËÐÐ
 404   2          return  0;    //³É¹¦
 405   2        }
 406   1      
 407   1        if(TIM == Timer3)   //Timer3,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 408   1        {
 409   2          if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
 410   2          T4T3M &= 0xf0;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 411   2          IE2  &= ~(1<<5);  //½ûÖ¹ÖÐ¶Ï
 412   2          if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<5);  //ÔÊÐíÖÐ¶Ï
 413   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   T4T3M |=  (1<<1); //1T
 414   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  T4T3M |=  (3<<1); //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 415   2          if(TIMx->TIM_ClkOut == ENABLE)  T4T3M |=  1;  //Êä³öÊ±ÖÓ
 416   2      
 417   2          TH3 = (u8)(TIMx->TIM_Value >> 8);
 418   2          TL3 = (u8)TIMx->TIM_Value;
 419   2          if(TIMx->TIM_Run == ENABLE) T4T3M |=  (1<<3); //¿ªÊ¼ÔËÐÐ
C51 COMPILER V8.05a   TIMER                                                                06/25/2017 19:15:10 PAGE 8   

 420   2          return  0;    //³É¹¦
 421   2        }
 422   1      
 423   1        if(TIM == Timer4)   //Timer4,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 424   1        {
 425   2          if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
 426   2          T4T3M &= 0x0f;    //Í£Ö¹¼ÆÊý, ¶¨Ê±Ä£Ê½, 12TÄ£Ê½, ²»Êä³öÊ±ÖÓ
 427   2          IE2  &= ~(1<<6);  //½ûÖ¹ÖÐ¶Ï
 428   2          if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<6);  //ÔÊÐíÖÐ¶Ï
 429   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   T4T3M |=  (1<<5); //1T
 430   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  T4T3M |=  (3<<5); //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 431   2          if(TIMx->TIM_ClkOut == ENABLE)  T4T3M |=  (1<<4); //Êä³öÊ±ÖÓ
 432   2      
 433   2          TH4 = (u8)(TIMx->TIM_Value >> 8);
 434   2          TL4 = (u8)TIMx->TIM_Value;
 435   2          if(TIMx->TIM_Run == ENABLE) T4T3M |=  (1<<7); //¿ªÊ¼ÔËÐÐ
 436   2          return  0;    //³É¹¦
 437   2        }
 438   1      
 439   1        return 2; //´íÎó
 440   1      }
 441          
 442          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1269    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
